1.java语言有哪些特点：
    1.跨平台性
    2.面向对象
    3.简单性
    4.安全性
    5.多线程
    6.垃圾回收机制
    7.丰富的类库

2.面向对象和面向过程的区别
    面向过程：强调实现功能的具体逻辑，如：把一个大象放进冰箱分解几步：打开冰箱，把大象放入冰箱里，关闭冰箱
    面向对象：强调实现功能所需要的对象，如：把一个大象放进冰箱，应该调用冰箱的开门，把大象放进去，关门等方法

3.八种基本数据类型的大小和他们的封装类：
    八种基本数据类型为：**short**,byte,**int**,long,float,double，boolean,char;
                    1,2,4,8,4,8,1,2字节
    对应的封装类：Integer,Byte，Short,Long,Float,Double,Boolea,Character;
    大小分别为：byte(1字节),short(2字节)，int(4字节),long(8字节),float(4字节),double(8字节),boolean(1字节),char(2字节)

4.java的基本类型为什么要设计封装类
    1.java是一门面向对象的语言，基本类型不是对象，不能够直接使用。
    2.基本类型不具有方法调用，在实际的开发中不方便操作
    3.基本类型没有空值，而在实际开发中有时候需要表示空值
    4.基本类型无法满足集合操作。

5.instance of关键字的作用
    1.判断一个对象是否是一个类的实例
    2.判断一个对象是否实现了某个接口
    3.判断一个对象是否是某个类的子类

6.重载与重写的区别
    重载:用于区别方法名相同，但是参数类型不同的方法，可以出现在同一个类中，也可以出现在父子类中。在重载时，方法名相同，参数列表不同，返回值类型可以相同也可以不同。
    重写:发生在子类继承父类时对父类方法的重新实现。在重写时，方法名、参数列表、返回值类型必须相同。

7.equals和==的区别
    equals：用于比对两个对象的值是否相同，但是有些对象会重写equals方法来实现自定义的比较逻辑。
    ==：用于比较两个对象的额地址值是否相同。

8.HashCode的作用
    
9.既然HashCode是随机数，那么为什么对象每次调用时，打印的hashCode是一样的？
    对象创建时是没有hashCode的，第一次调用hashCode()方法时会根据对象的内存地址计算出一个整数值，并将其缓存起来,放到MarkWord中。
    之后每次调用hashCode()方法时，都会返回这个缓存的值，因此在同一个对象上多次调用hashCode()方法会得到相同的结果。

10.equals和HashCode的关系：
    若两个对象通过 equals() 比较为 true，则它们的 hashCode() 必须返回相同的值；
    若两个对象的 hashCode() 返回不同的值，则它们的 equals() 比较必须为 false。
    若两个对象的 hashCode() 返回相同的值，则它们的 equals() 比较不一定为 true。
    总结：equals方法更偏向于业务层面，而hashCode方法更偏向于技术层面，且hashCode更注重内容的唯一性。，而"=="则多用于比较地址是否一致。

11.Java中的String、StringBuffer和StringBuilder的区别
    String:不可变字符序列，线程安全，适用于少量字符串操作
    StringBuffer:可变字符序列，线程安全，适用于多线程环境下的字符串操作
    StringBuilder:可变字符序列，非线程安全，适用于单线程环境下的字符串操作

12.ArrayList和LinkedList的区别
    ArrayList:基于动态数组实现，支持快速随机访问，适合频繁读取操作，但插入和删除操作较慢。
    LinkedList:基于双向链表实现，适合频繁插入和删除操作，但随机访问较慢。
        ArrayList每次扩容是原来的1.5倍，每次扩容需要在新数组中复制旧数组的数据，效率较低。
        由于扩容的效率低，我们尽量在初始化的时候定义容量。直接new ArrayList的话，初始容量为0，添加第一个元素后，容量为10。

13.HashMap和HashTable的区别：
        1.HashMap是非线程安全的，适用于单线程环境，效率较高；HashTable是线程安全的，适用于多线程环境，但效率较低。
        2.HashMap允许一个null键和多个null值；HashTable不允许null键和null值。
        3.HashMap的迭代器是快速失败的（fail-fast），在迭代过程中如果结构被修改会抛出ConcurrentModificationException异常；HashTable的枚举器不是快速失败的。
        4.HashMap继承自AbstractMap类；HashTable继承自Dictionary类。
        5.HashMap的初始容量默认是16，加载因子是0.75；HashTable的初始容量默认是11，加载因子是0.75。
        6.HashMap的底层实现是数组加链表（JDK1.8及以后是数组加链表加红黑树）；HashTable的底层实现是数组加链表。
        7.HashMap的性能优于HashTable，尤其是在高并发场景下。
        8.HashMap的put操作允许覆盖已有的key；HashTable的put操作不允许覆盖已有的key。

14.Collection的包结构,与Collections的区别？
    Collection是一个接口，位于java.util包下，是所有集合类的根接口，定义了集合的基本操作方法，如添加、删除、清空等。
    Collections是一个工具类，位于java.util包下，提供了一些静态方法，用于操作或返回集合，如排序、查找、同步等。

15.java的四种引用，强软弱虚
    强引用：最常见的引用类型，引用对象不会被垃圾回收器回收，除非引用被置为null。
    软引用：当内存不足时，垃圾回收器会回收软引用指向的对象，适用于缓存等场景。
    弱引用：垃圾回收器在下一次回收时就会回收弱引用指向的对象，适用于监听器等场景。
    虚引用：无法通过虚引用访问对象，主要用于跟踪对象的生命周期，当垃圾回收器准备回收一个对象时，如果该对象有虚引用，则会在回收前将该虚引用加入到一个引用队列中。

16.泛型的特点：
    1.类型安全：在编译时进行类型检查，避免了运行时的类型转换异常。
    2.代码重用：通过泛型可以编写通用的代码，适用于不同的数据类型。
    3.提高代码可读性：使用泛型可以明确表示集合中存储的对象类型，增强代码的可读性。
    4.支持多种数据类型：泛型可以与任何引用类型一起使用，包括自定义类和接口。
    5.与基本数据类型不兼容：泛型只能与引用类型一起使用，不能直接与基本数据类型（如int、char等）一起使用，但可以使用其对应的包装类（如Integer、Character等）。
    6.类型擦除：Java中的泛型在编译时会进行类型擦除，即将泛型类型替换为Object类型，这意味着在运行时无法获取泛型的具体类型信息。

17.transient关键字
    控制对象序列化的关键字，修饰的对象不被序列化。

18.java创建对象有几种方式：
    1.New关键字
    2.class.formane
    3.clone
    4.通过反序列化
    5.通过工厂模式创建

19.深拷贝和浅拷贝的区别是什么
    浅拷贝：只复制对象本身和基本数据类型，但是不复制引用类型。
        浅拷贝的方式：
            1.实现Cloneable接口并重写clone()方法
            2.通过序列化和反序列化实现
    深拷贝：复制对象的基本类型和引用类型。
        深拷贝的方式：
            1.实现Cloneable接口并在clone()方法中递归调用引用类型的clone()方法
            2.通过序列化和反序列化实现
20.final有哪些用法：
        1.定义常量，使常量不可改变
        2.定义方法，使方法不可重写
        3.修饰类，使类不可被继承

21.static有哪些用法
        1.修饰常量，常量会静态加载。
        2.修饰方法，方法会在类加载时加载，，可以通过静态名称调用
        3.修饰静态代码块，使静态代码块在类加载的时候执行，且只加载一次

22.3*0.1`==`0.3返回值是什么
        返回false,因为浮点数在计算机中是以二进制形式存储的，某些十进制小数无法精确表示为二进制小数，导致计算结果出现微小误差。

23.a=a+b与a+=b有什么区别吗?
        有区别，a=a+b如果存在类型不一致，可能需要强转，如果没有强转，则会报错。
        a+=b会自动进行类型转换，不会报错。

24.try catch finally，try里有return，finally还执行么？
        finally会执行
        特殊情况：try 中的 return 会先记录返回值，finally 中修改变量不会改变已记录的返回值。（见代码：testFinally.java），但如果操作的是引用类型，

25.Exception与Error的包结构
        Exception和Error都继承自Throwable类，位于java.lang包下。
        Exception表示程序中可以处理的异常情况，如文件未找到、网络连接失败等。
        Error表示程序中无法处理的严重错误，如内存溢出、虚拟机错误等。
        Exception:
            1.检查型异常（Checked Exception）：必须在代码中显式处理，否则编译不通过，如IOException、SQLException等。
            2.非检查型异常（Unchecked Exception）：不强制要求处理，通常是程序逻辑错误引起的，如NullPointerException、ArrayIndexOutOfBoundsException等。
        Error: 通常是由虚拟机引起的严重问题，如OutOfMemoryError、StackOverflowError等。

26.进程，线程和程序的基本概念
        程序：程序是一系列静态指令的集合，是保存在介质中的一段程序。
        进程：进程是程序调用的一次执行过程，是系统进行资源分配和调度的一个独立单位。
        线程：线程是CPU执行和调度的一个基本单位。
        简单来说：程序是 “剧本”，进程是 “正在演出的戏剧”，线程是 “戏剧中的角色”—— 剧本（程序）本身不活动，戏剧（进程）是剧本的一次演出过程，而角色（线程）在戏剧中协同完成表演。

27.线程的几种状态
    1.新建状态：当java中New 了一个Thread但是没有调用Start方法时，线程处于新建状态.线程已分配内存，但未进入线程调度队列，不占用 CPU 资源。
    2.就绪状态:调用 start() 方法后，线程进入就绪状态。此时线程已加入调度队列，等待 CPU 分配时间片。
    3.运行状态：就绪状态的线程获得 CPU 时间片后，进入运行状态，执行 run() 方法中的逻辑。
    4.阻塞状态：线程因竞争同步锁失败（如进入 synchronized 代码块但锁被其他线程持有），暂时放弃 CPU 资源，进入阻塞状态。线程不参与 CPU 调度，直到获得同步锁后，才会转为就绪状态；
阻塞状态仅与 “同步锁竞争” 相关。
    5.等待状态：线程调用 wait() 方法后，进入等待状态，直到其他线程调用 notify() 或 notifyAll() 方法唤醒它。等待状态与 “对象监视器” 相关。
    6.超时等待状态：线程调用带有超时参数的 wait() 方法后，进入超时等待状态。如果在指定时间内未被唤醒，线程会自动转为就绪状态。
    7.终止状态：线程执行完run方法，或者因异常退出，或者被其他线程强制终止，进入终止状态。终止状态的线程不再参与调度，资源会被回收。

28.线程的优先级
    线程优先级是一个整数值，范围从1到10，默认优先级为5。优先级高的线程在争夺CPU资源时更有优势，但并不保证一定会先执行。
    线程优先级可以通过setPriority(int newPriority)方法设置，通过getPriority()方法获取。
    线程优先级的设置应谨慎使用，过高或过低的优先级可能导致线程饥饿或资源浪费。

29.线程的几种创建方式
    1.继承Thread类：创建一个类继承Thread类，并重写run()方法，然后创建该类的实例并调用start()方法启动线程。
    2.实现Runnable接口：创建一个类实现Runnable接口，并实现run()方法，然后创建Thread类的实例，传入Runnable对象，并调用start()方法启动线程。
    3.实现Callable接口：创建一个类实现Callable接口，并实现call()方法，然后使用FutureTask包装Callable对象，最后创建Thread类的实例，传入FutureTask对象，并调用start()方法启动线程。Callable接口可以有返回值，并且可以抛出异常。
    4.使用线程池：通过Executors类创建线程池，如FixedThreadPool、CachedThreadPool等，然后提交Runnable或Callable任务到线程池执行。线程池可以有效管理和复用线程资源，提高性能。

30.java中的IO流
    BIO:Blocking IO:最早的IO，特点是会阻塞线程，直到IO操作完成。缺点是性能比较差。BIO适合连接数较少的应用，比如Servlet。
        用户态发起一次请求，看内核态有没有想要的数据到达，如果没有，就阻塞等待，等到数据到达后，再从内核态拷贝数据到用户态，用户态再进行处理。
    AIO:完全异步的 I/O 模型，操作发起后，系统会在后台完成整个 I/O 操作，当操作完成时通知应用程序（通过回调或 Future），期间不会阻塞线程。适合多人聊天室，文件聊天等。
        用户线程通过系统调用内核注册某个IO操作，内核态会在后台完成这个IO操作，等到IO操作完成后，再通知用户态。
        AIO也是使用epoll实现的。创建Socket连接的时候，创建了BOSS线程，client连接的FD注册到BOSS线程的epoll中，BOSS线程轮询这些FD，当有连接进来时，BOSS线程会把这个连接的FD注册到WORK线程的epoll中，WORK线程轮询这些FD，当有数据到达时，WORK线程会读取数据，然后通过回调函数通知用户态。
        BOSS线程只负责处理连接并分发请求，WORK线程负责处理具体的IO操作。
    NIO:同步非阻塞，采用 "多路复用" 模式，一个线程可以管理多个通道（连接），通过选择器轮询通道，只处理那些有事件发生的通道。
        对于NIO:客户端会在服务端注册多个channel,服务端通过轮询器（selector）轮询这些channel，观察这些channel的状态，如果是可读的，就进行读操作，如果是可写的，就进行写操作。
               但是会有个问题：channel是在内核中，而循环是在用户空间，每次轮询都需要从用户空间切换到内核空间，效率比较低。（相当于人在阳台烤串，人在卧室，每次都需要从卧室走到阳台，看哪一串有没有熟，熟了就拿
                其中一串，然后回到卧室，下次再去拿.......正确的方法是：每次去阳台的时候拿多个烤串）。
               多路复用：在计算机中，对应的就是要把插叙状态的这些通道的fds文件描述符传给内核，让内核去轮询这些fds，等到有事件发生时，再通知用户空间。这样就避免了频繁的用户态和内核态切换，提高了效率。
                这里一次查询多个fds的操作就是多路复用。多路复用的实现有三种方式：select(每次查询的数量有限制),poll(每次查询的数量没有限制),epoll(不循环，直接找到状态变化的通道)。
                    epoll原理:
                        1.serverSocket:创建ServerSocket,
                        2.bind:绑定端口，设置为非阻塞
                        3.listen:监听端口
                        4.epoll_create:创建epoll对象,调用后会在内核中返回两个空间，一个是红黑树，一个是事件表。
                        5.epoll_ctl:把serverSocket的fd文件描述符放到红黑树里，并设置关注的事件类型（读，写，异常等）。
                        6.epoll_wait:从双向链表里获取状态变化的fd,如果没有变化，就阻塞等待。
                                当网卡接受到数据时，内核会检测到serverSocket的状态变化，然后把这个fd放到双向链表里，等待用户空间来取。
                        7.accept:如果是serverSocket有状态变化，说明有新的连接进来，调用accept方法，拿到新的socket。

31.JAVA常用流有哪些？需要实际操作
            按照操作数据类型划分： 
                字节流：
                    输入字节流：FileInputStream：从文件读取字节
                              ByteArrayInputStream：从字节数组读取数据
                              BufferedInputStream：带缓冲的字节输入流（提高读取效率）
                              ObjectInputStream：反序列化，从流中读取对象
                    输出字节流：FileOutputStream：向文件写入字节
                              ByteArrayOutputStream：向字节数组写入数据
                              BufferedOutputStream：带缓冲的字节输出流（提高写入效率）
                              ObjectOutputStream：序列化，将对象写入流
                字符流：
                    输入字符流（Reader）：从数据源读取字符（自动处理编码转换）
                                        FileReader：从文件读取字符
                                        CharArrayReader：从字符数组读取数据
                                        BufferedReader：带缓冲的字符输入流（支持 readLine() 读取一行）
                                        InputStreamReader：字节流转换为字符流（可指定编码）
                    输出字符流（Writer）：向目标写入字符
                                        FileWriter：向文件写入字符
                                        CharArrayWriter：向字符数组写入数据
                                        BufferedWriter：带缓冲的字符输出流（支持 newLine() 换行）
                                        OutputStreamWriter：字符流转换为字节流（可指定编码）
                按照功能划分：
                1. 节点流（直接操作数据源 / 目标的流，如文件、数组）
                        字节节点流：FileInputStream、FileOutputStream、ByteArrayInputStream 等
                        字符节点流：FileReader、FileWriter、CharArrayReader 等
                2. 处理流（包装节点流，增强功能，如缓冲、转换、对象序列化）
                        缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter（减少 I/O 次数，提高效率）
                        转换流：InputStreamReader、OutputStreamWriter（字节流与字符流的桥梁，可指定编码如 UTF-8）
                        对象流：ObjectInputStream、ObjectOutputStream（实现对象的序列化与反序列化）
                        打印流：PrintStream（如 System.out）、PrintWriter（方便打印各种数据类型，支持自动刷新）


32.什么是异步操作？需要实际操作。
        异步操作（Asynchronous Operation） 是指一种不阻塞当前程序执行流程的任务处理方式。
        异步操作之后如何通知结果？
            1.回调函数：发起一个请求，在任务完成后，系统自动调用该函数，并将结果作为参数传入。
            2.Future/Promise模式:
                Future:代表一个"未来会完成的任务"，主线程可以通过get()等方法获取结果，如果任务未完成，get()会阻塞等待。
                Promise:Future的增强版，通过then()(成功回调)，catch(失败回调)链式调用处理结果，逻辑更清晰。
            3.事件驱动：基于"事件"和"监听器"的模式：异步完成成功时，触发一个特定"事件"；主线程通过注册"时间监听器"，在事件触发时进行处理逻辑（常见于GUI编程，消息队列）。
            4.消息队列：适用于分布式系统或多线程通信：异步任务的发起方将 “任务请求” 发送到消息队列，然后直接返回；消费方（独立线程 / 进程）从队列中读取请求并执行，执行完成后将结果存入另一个队列，发起方再从结果队列中获取结果（完全解耦）。
        异步操作的使用场景：      
            1.耗时 I/O 操作：网络请求（如接口调用、下载文件）、文件读写（如读取大文件）、数据库查询（如复杂 SQL 执行）—— 这些场景数据等待时间过长，使用异步可以让线程在等待期间处理其他任务。
            2.高并发场景：如 Web 服务器处理大量请求（如 Tomcat 的 NIO 模型）、秒杀系统处理瞬时流量 —— 异步可避免线程被耗尽，提升系统吞吐量。
            3.非实时性任务：如日志上报、数据统计、邮件发送 —— 这些任务无需立即完成，异步执行可减少主线程响应时间。
        异步操作的注意事项：
            1.线程安全问题：异步任务若修改共享变量（如静态变量、成员变量），需通过锁（synchronized、Lock）或原子类（AtomicInteger）保证线程安全，避免数据竞争。
            2.异常处理：异步任务的异常无法直接通过 try-catch 捕获（因任务在其他线程执行），需通过回调（如 Promise.catch()）、Future 的 get() 异常捕获（需处理 ExecutionException）等方式处理。
            3.资源泄漏风险：若异步任务持有资源（如文件流、数据库连接），需确保任务完成后释放资源（如使用 try-with-resources、在回调中关闭资源）。
            4.结果顺序问题：多个异步任务的执行顺序不确定（取决于线程调度），若需按发起顺序处理结果，需通过 CompletableFuture.thenCompose()（串行）、CompletableFuture.allOf()（并行后统一处理）等方式控制。

33.java反射的作用和原理
            Java 中每个类被加载到 JVM 后，都会生成一个唯一的 java.lang.Class 对象，该对象包含了这个类的所有元信息（如类名、父类、接口、方法、字段等）。这些数据存在于JVM的方法区的类元数据。方法区：存储类名、父类、接口、方法表、字段表等。方法区是元数据的 “存储地”，类元数据是反射的 “数据源”。
            反射的底层实现
                反射的能力源于 JVM 对类元数据的管理：
                    类加载阶段：JVM 将 .class 文件加载到内存，解析出类的结构信息（如方法表、字段表等），并生成 Class 对象。
                    反射 API 调用：Class、Method 等反射类的方法会通过 JVM 提供的 native 方法（如 sun.reflect.NativeMethodAccessorImpl）直接操作类的元数据。
                    访问权限控制：对于私有成员，反射通过 setAccessible(true) 关闭 JVM 的访问检查（跳过 checkAccess 验证），从而实现对私有成员的操作。    
            反射常用方法：
                1.获取 Class 对象：
                    Class.forName("com.example.MyClass")：通过类的全限定名获取 Class 对象，常用于动态加载类。
                    MyClass.class：通过类名直接获取 Class 对象，编译时确定类。
                    myObject.getClass()：通过对象实例获取 Class 对象，运行时确定类。
                2.创建对象实例：
                    Class.newInstance()：调用无参构造器创建对象，已过时，不推荐使用。
                    Constructor<T>.newInstance(Object... initargs)：通过指定构造器创建对象，支持有参构造器。
                3.访问字段（属性）：
                    Field field = clazz.getDeclaredField("fieldName")：获取指定名称的字段（包括私有字段）。
                    field.setAccessible(true)：取消访问检查，允许访问私有字段。
                    field.get(Object obj)：获取字段值。
                    field.set(Object obj, Object value)：设置字段值。
                4.调用方法：
                    Method method = clazz.getDeclaredMethod("methodName", Class<?>... parameterTypes)：获取指定名称和参数类型的方法（包括私有方法）。
                    method.setAccessible(true)：取消访问检查，允许调用私有方法。
                    method.invoke(Object obj, Object... args)：调用方法并传入参数。
                5.获取类信息：
                    clazz.getSuperclass()：获取父类。
                    clazz.getInterfaces()：获取实现的接口列表。
                    clazz.getModifiers()：获取类的修饰符（如 public、abstract）。
34.char类型能不能转成int类型，能不能转成String类型,能不能转成double类型
                char类型可以转成int类型，转成String类型，不能转成double类型
                    char转int:直接赋值即可，char类型在内存中是以整数形式存储的
                    char转String:可以通过String.valueOf(char)或者Character.toString(char)方法转换
                    char转double:不能直接转换，需要先转成int类型，再转成double类型
35.面向对象有哪些特征？
    1.封装：方法的内容对外封装，只暴露方法名，参数，返回值等信息
    2.继承：子类通过继承父类来实现并改造父类的方法。
    3.多态：同一行为在不同对象上表现出不同的形态。简单来说，就是 “一个接口，多种实现”，允许使用统一的方式操作不同类型的对象，而无需关心对象的具体类型。多态最典型的表现是：父类引用指向子类对象，并调用子类重写的方法。此时，程序会根据对象的实际类型（而非引用类型）执行对应的方法，实现 “同一种调用，不同的执行结果”。
        多态实现的三个条件：1.继承关系。2.方法重写。3.父类引用指向子类对象。


36.访问修饰符public,protected,default,private的区别
        public:所有包下都可以使用。
        protected:同包下和子类可以使用。
        default:同包下可以使用。
        private:只能在本类中使用。

37.short s1=1; s1=s1+1;编译通过吗？为什么？
        编译不通过，s1+1的结果是int类型，不能直接赋值给short类型，需要强制转换。

38.String str = "hello"; str = str + "world"; 这段代码会创建几个String对象？为什么？
        这段代码会创建两个String对象。
        第一个对象是"hello"，在字符串常量池中创建。
        第二个对象是"helloworld"，在堆内存中创建，因为字符串拼接会创建一个新的字符串对象，原来的字符串对象不会被修改。    

39.String str = "aaa",与 String str = new String("aaa")的区别？
        String str = "aaa"：这种方式会在字符串常量池中创建一个字符串对象，如果常量池中已经存在该字符串，则直接引用该对象，不会重复创建。
        String str = new String("aaa")：这种方式会在堆内存中创建一个新的字符串对象，即使常量池中已经存在该字符串，也会创建一个新的对象。
        总结：前者更节省内存，后者每次都会创建新的对象。

40.接口和抽象类的区别
        1.抽象类可以有构造方法，接口没有构造方法。
        2.抽象类可以有成员变量，接口只能有常量（public static final）。
        3.抽象类可以有普通方法，接口只能有抽象方法（Java 8 之后可以有默认方法和静态方法）。
        4.一个类只能继承一个抽象类，但可以实现多个接口。
        5.抽象类适用于描述 "是什么" 的关系，接口适用于描述 "能做什么" 的关系。
        6.抽象类可以包含非抽象方法，接口中的方法默认是抽象的（除非是默认方法或静态方法）。
        7.抽象类可以有访问修饰符（public、protected、private），接口中的成员默认是 public。        

41.接口有什么特点
        1.接口是一种特殊的抽象类，不能被实例化，只能被实现。
        2.接口中的方法默认是 public abstract 的，成员变量默认是 public static final 的。
        3.一个类可以实现多个接口，实现接口时必须实现接口中的所有方法。
        4.接口可以继承多个接口，形成接口的多重继承。
        5.接口适用于描述 "能做什么" 的关系，强调行为规范。
        6.从 Java 8 开始，接口可以包含默认方法（default）和静态方法（static），允许在接口中提供方法的具体实现。
        7.接口不能有构造方法，因为它不能被实例化。
        8.接口中的成员变量必须初始化，因为它们是常量（public static final）。

42.java创建对象有哪几种方式
    1.使用 new 关键字
    2.使用 Class.forName() 方法
    3.使用 ClassLoader 的 loadClass() 方法
    4.使用 clone() 方法
    5.使用反序列化
    6.使用工厂模式创建对象        

43.内部类和静态内部类有什么区别
        1.静态内部类是静态的，可以直接通过外部类访问，而内部类是非静态的，必须通过外部类的实例访问。
        2.静态内部类不能访问外部类的非静态成员，而内部类可以访问外部类的所有成员。
        3.静态内部类不能使用外部类的 this 关键字，而内部类可以使用外部类的 this 关键字。
        4.静态内部类在加载时不会创建外部类的实例，而内部类在创建时会隐式地持有一个外部类的引用。
        5.静态内部类适用于不需要访问外部类实例成员的场景，而内部类适用于需要访问外部类实例成员的场景。        

44.数据库连接池有什么好处
        1.提高性能：连接池可以复用已有的连接，避免频繁创建和销毁连接的开销，提高数据库操作的效率。
        2.资源管理：连接池可以限制最大连接数，防止数据库连接过多导致资源耗尽。
        3.简化编程：使用连接池可以简化数据库连接的管理，开发人员不需要手动管理连接的创建和关闭。
        4.提高应用程序的稳定性：连接池可以检测和回收无效连接，确保应用程序始终使用有效的数据库连接。
        5.支持事务管理：连接池通常支持事务管理，可以方便地进行事务处理。

47.构造器能否被重写？
        构造器不能被重写，因为构造器不是继承来的方法，而是类的一部分。每个类都有自己的构造器，不能通过继承来改变父类的构造器。

48.静态嵌套类和内部类有什么不同
        1.静态嵌套类是静态的，可以直接通过外部类访问，而内部类是非静态的，必须通过外部类的实例访问。
        2.静态嵌套类不能访问外部类的非静态成员，而内部类可以访问外部类的所有成员。
        3.静态嵌套类不能使用外部类的 this 关键字，而内部类可以使用外部类的 this 关键字。
        4.静态嵌套类在加载时不会创建外部类的实例，而内部类在创建时会隐式地持有一个外部类的引用。
        5.静态嵌套类适用于不需要访问外部类实例成员的场景，而内部类适用于需要访问外部类实例成员的场景。

49.接口能否继承接口？抽象类能否实现接口？抽象类是否可继承具体类？
    都可以

50.java异常分为几种？
    运行时异常和编译时异常



52.

53.
        
    