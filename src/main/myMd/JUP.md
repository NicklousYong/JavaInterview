//高并发机制题目

1.ThreadLocal的原理和应用场景？
    ThreadLocal是Java中的一个类，它提供了线程局部变量的机制。每个线程都有自己的独立变量副本，互不干扰。
    ThreadLocal通过维护一个Map来存储每个线程的变量副本，键是当前线程，值是该线程的变量副本。
    当调用 threadLocal.set(value) 时，实际是向当前线程的 ThreadLocalMap 中添加键值对（this -> value）。
    由于每个线程的 ThreadLocalMap 是私有变量，不同线程的 ThreadLocal 操作仅影响各自的副本，因此实现了线程间的数据隔离，无需加锁即可保证线程安全。
    ThreadLocalMap 采用线性探测法解决哈希冲突（区别于 HashMap 的链表法），其内部由 Entry 数组实现，Entry 继承自 WeakReference<ThreadLocal>，目的是在 ThreadLocal 实例被回收后，自动释放对应的 Entry（减少内存泄漏风险）。
        1.ThreadLocal内维护了一个ThreadLocalMap对象，key 是 ThreadLocal 实例本身，value 是线程要存储的变量副本。
        2.ThreadLocalMap 是私有变量，拒绝外部访问。
    注意：
        ThreadLocal 若使用不当，可能导致内存泄漏：
            原因：ThreadLocalMap 的 Entry 中，key 是 ThreadLocal 的弱引用（WeakReference），但 value 是强引用。若 ThreadLocal 实例被回收（key 为 null），而线程仍存活（如线程池核心线程），value 会因强引用无法被回收，导致内存泄漏。
        解决方案：
            使用完 ThreadLocal 后，务必调用 remove() 方法清除 value。
            避免使用静态 ThreadLocal 长期持有大对象。

2.线性探测法：

3.java中实现多线程有几种方法：
        1.继承Thread类
        2.实现Runnable接口
        3.实现Callable接口
        4.使用线程池（Executor框架）
        5.使用ForkJoinPool（适合大任务拆分）
        6.使用CompletableFuture（异步编程）
        7.使用Timer和TimerTask（定时任务）
        8.使用ScheduledExecutorService（定时任务）
4.4种线程池
    1.newFixedThreadPool(int nThreads)：
        创建一个固定大小的线程池，适合处理CPU密集型任务，避免频繁创建销毁线程的开销。
    2.newCachedThreadPool()：
        创建一个可缓存的线程池，适合处理I/O密集型任务，线程数根据需要动态调整，空闲线程60秒后被回收。
    3.newSingleThreadExecutor()：
        创建一个单线程化的线程池，所有任务按顺序执行，适合需要顺序执行任务的场景。
    4.newScheduledThreadPool(int corePoolSize)：
        创建一个支持定时及周期性任务执行的线程池，适合需要定时或周期性执行任务的场景。
5.如何停止一个正在工作的线程？
    1.使用标志位：
        在线程类中定义一个volatile的布尔变量作为标志位，线程在运行时定期检查该标志位，当标志位被设置为false时，线程退出运行。
    2.使用interrupt()方法：
        调用线程的interrupt()方法来中断线程，线程在运行时可以通过检查Thread.interrupted()方法或捕获InterruptedException来响应中断请求并退出。
    3.使用Future的cancel()方法：
        如果线程是通过ExecutorService提交的任务，可以通过Future对象的cancel()方法来取消任务，传入true参数可以尝试中断正在运行的线程。
    4.使用Thread.stop()方法（不推荐）：
        该方法已被弃用，因为它会导致线程在任意位置停止，可能引发数据不一致和资源泄漏问题。
6.notify()和notifyAll()的区别？
    notify()：唤醒一个等待该对象监视器的线程。如果有多个线程在等待，则随机选择一个线程唤醒。被唤醒的线程会继续执行，但需要重新获取对象锁。
    notifyAll()：唤醒所有等待该对象监视器的线程。所有被唤醒的线程会竞争对象锁，只有一个线程能成功获取锁并继续执行，其他线程继续等待。
    总结：
        notify()适用于只需要唤醒一个线程的场景，效率较高，但可能导致某些线程长时间等待。
        notifyAll()适用于需要唤醒所有等待线程的场景，确保所有线程都有机会执行，但效率较低，因为所有线程都会竞争锁。
7.sleep()和wait()的区别？
    1.所属类不同：
        sleep()是Thread类的静态方法，用于让当前线程休眠指定时间。
        wait()是Object类的方法，用于让当前线程等待，直到被notify()或notifyAll()唤醒。
    2.锁的释放：
        sleep()不会释放锁，线程在休眠期间仍然持有对象锁，其他线程无法访问该锁。
        wait()会释放锁，线程进入等待状态后会释放对象锁，允许其他线程访问该锁。
    3.使用场景不同：
        sleep()通常用于控制线程执行的节奏，例如定时任务或轮询操作。
        wait()通常用于线程间通信，等待某个条件满足后再继续执行。
    4.必须在同步块中调用：
        wait()必须在同步块或同步方法中调用，否则会抛出IllegalMonitorStateException异常。
        sleep()可以在任何地方调用，不需要在同步块中。
8.进程和线程的区别？
    程序：程序是一系列静态指令的集合，是保存在介质中的一段程序。
    进程：进程是程序调用的一次执行过程，是系统进行资源分配和调度的一个独立单位。
    线程：线程是CPU执行和调度的一个基本单位。
    简单来说：程序是 “剧本”，进程是 “正在演出的戏剧”，线程是 “戏剧中的角色”—— 剧本（程序）本身不活动，戏剧（进程）是剧本的一次演出过程，而角色（线程）在戏剧中协同完成表演。
9.线程的几种状态
    1.新建状态：当java中New 了一个Thread但是没有调用Start方法时，线程处于新建状态.线程已分配内存，但未进入线程调度队列，不占用 CPU 资源。
    2.就绪状态:调用 start() 方法后，线程进入就绪状态。此时线程已加入调度队列，等待 CPU 分配时间片。
    3.运行状态：就绪状态的线程获得 CPU 时间片后，进入运行状态，执行 run() 方法中的逻辑。
    4.阻塞状态：线程因竞争同步锁失败（如进入 synchronized 代码块但锁被其他线程持有），暂时放弃 CPU 资源，进入阻塞状态。线程不参与 CPU 调度，直到获得同步锁后，才会转为就绪状态；
    阻塞状态仅与 “同步锁竞争” 相关。
    5.等待状态：线程调用 wait() 方法后，进入等待状态，直到其他线程调用 notify() 或 notifyAll() 方法唤醒它。等待状态与 “对象监视器” 相关。
    6.超时等待状态：线程调用带有超时参数的 wait() 方法后，进入超时等待状态。如果在指定时间内未被唤醒，线程会自动转为就绪状态。
    7.终止状态：线程执行完run方法，或者因异常退出，或者被其他线程强制终止，进入终止状态。终止状态的线程不再参与调度，资源会被回收。
10.synchronized可以修饰哪些内容？
    1.修饰非静态方法：修饰当前对象实例。即调用该方法的对象本身。
    2.修饰静态方法：该类所创建的对象使用同一把锁。
    3.修饰代码块：可以指定任意对象作为锁，灵活性更高。通常用于保护临界区代码。代码块内可以有当前实例，类对象，自定义对象。
11.什么是死锁？
    死锁是指两个或多个线程在执行过程中，因争夺资源而造成一种互相等待的现象，从而使得这些线程都无法继续执行下去。
    产生死锁的必要条件：
        1.互斥条件：资源不能被多个线程共享，某个资源一次只能被一个线程占用。
        2.占有且等待条件：一个线程至少持有一个资源，并且等待获取其他线程持有的资源。
        3.不剥夺条件：线程已获得的资源在未使用完之前，不能被强制剥夺，只能由线程自己释放。
        4.循环等待条件：存在一种资源循环等待关系，即线程A等待线程B持有的资源，线程B等待线程C持有的资源，……，最后一个线程又等待线程A持有的资源。
    预防和避免死锁的方法(破坏其中一个条件就可以破坏死锁)：
        1.破坏互斥条件：尽量减少对独占资源的使用，使用读写锁等机制允许多个线程同时访问共享资源。
        2.破坏占有且等待条件：要求线程在请求资源时一次性申请所需的所有资源，避免部分资源被占用而等待其他资源。
        3.破坏不剥夺条件：允许系统强制剥夺某些资源，例如通过超时机制释放长时间未使用的资源。
        4.破坏循环等待条件：为所有资源分配一个唯一编号，要求线程按编号顺序请求资源，避免形成循环等待。
    检测和恢复死锁的方法：
        1.检测死锁：通过定期检查系统状态，识别是否存在死锁情况，例如使用资源分配图等算法。
        2.恢复死锁：一旦检测到死锁，可以通过终止某些线程或回滚某些操作来打破死锁状态，使其他线程能够继续执行。
12.如何确保N个线程访问N个资源又不导致死锁？
        为每个资源分配唯一编号（如 0, 1, 2, ..., N-1）。
        所有线程必须按编号递增的顺序获取资源：无论线程需要哪些资源，都先获取编号小的资源，再获取编号大的资源。
        完成操作后按相反顺序释放资源（先释放大编号资源，再释放小编号资源，顺序不影响死锁预防，但保持一致性更佳）。
        其他措施：
            1.若无法固定顺序（如资源动态生成），可使用ReentrantLock.tryLock(timeout)，超时未获取资源则释放已持有的资源，避免无限等待：
            2.减少锁持有时间： 资源操作完成后立即释放锁，缩短线程持有资源的窗口，降低冲突概率。
            3.监控与告警： 通过jstack定期检查线程状态，若发现阻塞线程持有锁且等待其他锁，及时排查是否存在潜在死锁风险。
13.Java方法可以既是static又是synchronized吗？
        是的，Java 中的方法可以同时被 static 和 synchronized 修饰。这种组合在多线程场景中用于控制对静态资源（属于类的资源，而非实例资源） 的并发访问。
14.什么是thread dump
        thread dump（线程快照）是 Java 虚拟机（JVM）在某一时刻生成的所有线程状态的快照信息，包含线程的执行状态、调用栈、持有的锁、等待的资源等关键数据。
        1.线程基本信息：
            线程 ID（tid）、线程名称（Thread-0、main等）、线程状态（RUNNABLE、BLOCKED等）。
            线程优先级（priority）、是否为守护线程（daemon）。
        2.调用栈（Stack Trace）：
            线程当前执行的方法调用链，从栈顶（当前执行方法）到栈底（初始调用方法），包含类名、方法名、文件名及行号，用于定位线程正在执行的代码。
            锁信息：
                线程持有的锁（locked <0x000000076b7d0000>）。
                线程等待的锁（waiting to lock <0x000000076b7d0000>）。
                死锁信息（若存在死锁，会明确标记哪些线程相互等待）。
        3.JVM 信息：
                生成快照的 JVM 版本、进程 ID（pid）、生成时间等。
15.如何唤醒一个阻塞的线程？
            1.区分线程阻塞的类型
                首先需明确线程为何种原因阻塞（可通过thread dump查看线程状态）：
                BLOCKED状态：线程正在等待获取synchronized锁（因其他线程持有锁未释放）。
                    线程竞争synchronized锁失败，处于阻塞队列中。持有锁的线程释放锁（退出synchronized方法 / 代码块）。无需主动唤醒，只需让持有锁的线程尽快执行完同步代码并释放锁，阻塞线程会自动参与锁竞争。
                WAITING状态：线程通过Object.wait()、Thread.join()等方法进入无限期等待，需被其他线程显式唤醒。
                    Object.wait()：释放锁并等待，需通过notify()/notifyAll()唤醒。
                    Thread.join()：等待目标线程执行完毕，需目标线程执行结束。
                    LockSupport.park()：无锁阻塞，需通过LockSupport.unpark(thread)唤醒。
                TIMED_WAITING状态：线程通过Thread.sleep(time)、Object.wait(time)等方法进入限时等待，超时后会自动唤醒，也可被提前唤醒。
                上述三种状态均可通过通过interrupt()中断（需线程响应中断）唤醒。
16.简述Volatile关键字
            是用于保证变量可见性和禁止指令重排序的关键字；不保证原子性。
            核心作用：
                1.当一个变量被volatile修饰后，该变量的变化会立即刷新到主内存，保证变量对其他线程可见。 
                2.volatile通过禁止指令重排序，保证变量的操作执行与顺序。
                3.不保证原子性：当多个线程执行i++的时候，volatile不保证原子性，仍然会出现线程安全问题。
17.单例模式的双重检查(myVolatile.Singleton有相关代码)：
            第一次检查：在加锁前判断对象是否已初始化，若已初始化则直接返回，避免每次访问都加锁（提升性能）。
                    加锁：仅当对象未初始化时，才进入同步代码块（缩小锁范围）。
            第二次检查：在同步代码块内再次判断对象是否已初始化，防止多线程并发进入同步代码块时重复创建对象（保证线程安全）。
            为什么第二次检查要加volatile?
                1.防止指令重排序：在Java中，对象的创建过程可以分为三步：分配内存、初始化对象、将引用指向内存地址。
                由于编译器和处理器可能会对指令进行重排序，导致在多线程环境下，一个线程可能看到一个未完全初始化的对象引用。使用volatile关键字可以禁止这种重排序，确保对象在被其他线程看到之前已经完全初始化。
                2.保证可见性：volatile关键字确保当一个线程修改了volatile变量的值，其他线程能够立即看到这个变化。
                在双重检查锁定中，volatile确保当一个线程创建并赋值给实例变量后，其他线程能够立即看到这个已经初始化的实例，而不是看到一个旧的或未初始化的值。 
18.为什么wait和notify方法要在同步代码块中使用？
            wait()和notify()方法是Object类的方法，用于线程间的通信和协调。它们必须在同步代码块或同步方法中使用，原因如下：
                1.锁的持有：wait()方法会释放当前线程持有的对象锁，并使线程进入等待状态，直到被其他线程通过notify()或notifyAll()唤醒。
                如果不在同步代码块中调用wait()，当前线程不会持有对象锁，调用wait()会抛出IllegalMonitorStateException异常。
                2.线程安全：notify()和notifyAll()方法用于唤醒等待该对象监视器的线程。如果不在同步代码块中调用notify()，可能会导致多个线程同时访问共享资源，造成数据不一致或其他并发问题。
                通过在同步代码块中使用，可以确保只有持有对象锁的线程才能调用这些方法，从而保证线程安全。
                3.协调机制：wait()和notify()方法是基于对象监视器（monitor）的协调机制。
                只有在同步代码块中，线程才能正确地与对象监视器交互，实现等待和唤醒的功能。
                4.保证 “检查 - 等待” 逻辑的原子性，避免竞态条件
                线程调用wait方法通常是因为某个条件不满足（如队列为空、资源不足等），需要等待其他线程改变条件后再继续执行。
                而判断该条件的代码通常在代码块中，确保在调用wait之前，线程持有锁并检查条件是原子操作，避免在检查条件和调用wait之间被其他线程修改条件，导致逻辑错误。
19.java中的 interrupted 和 isInterrupted 有什么区别
                背景：线程的 “中断状态” 是一个 boolean 标志，用于表示线程是否被其他线程调用 interrupt() 方法请求中断。
                interrupted属于静态方法，而isInterrupted 属于实例方法。
                interrupted可以查询当前线程状态，。而isInterrupted可查询指定线程的中断状态。
                interrupted会清除中断状态，isInterrupted不会清除中断状态。
20.java中synchronized和 reentrantLock有什么不同

对比维度	                    synchronized	                                    ReentrantLock
本质	                        Java 语言关键字	                                    JDK 提供的工具类，依赖 API 实现（Java 代码）
可重入性	                    支持（同一线程可多次获取锁，自动记录重入次数）	            支持（显式实现可重入，通过 getHoldCount() 查看重入次数）
锁的释放	                    自动释放（同步块 / 方法执行完毕或抛出异常时）	            必须手动释放（需在 finally 块中调用 unlock()，否则可能导致死锁）
锁的获取方式	                默认非公平锁（“偏向锁→轻量级锁→重量级锁”，默认非公平）	    支持公平锁和非公平锁（构造函数 ReentrantLock(boolean fair) 指定，默认非公平）
响应中断	                    不支持（线程获取锁时被阻塞，无法被中断，只能一直等待）	    支持（通过 lockInterruptibly() 方法，可在等待锁时响应中断，避免死等）
超时获取锁	                不支持（获取不到锁时会一直阻塞）	                        支持（通过 tryLock(long timeout, TimeUnit unit) 实现，超时后放弃获取，避免永久阻塞）
锁状态查询	                无法直接查询（JVM 内部维护，无对外 API）	                可查询（通过 isLocked()、isHeldByCurrentThread()、getHoldCount() 等方法）
性能	                        JDK 1.6 后与 synchronized 性能差距缩小
使用复杂度	                简单（无需手动管理锁的释放，代码简洁）	                    复杂（需手动加锁 / 释放锁，需注意 finally 块的使用，避免遗漏 unlock()）
21.Thread类中的yield方法有什么作用？
    可以暂停当前正在执行的线程对象，并将其状态从运行状态转换为就绪状态，使得线程调度器有机会选择其他同等优先级的线程来执行。
22.java线程池中的submit和execute方法有什么区别？
    对比维度	execute()	                        submit()
    返回值	无返回值（void）	                    有返回值（Future 对象）
    任务类型	仅支持 Runnable 任务	                支持 Runnable 和 Callable 任务
    异常处理	异常直接抛出（若未捕获会导致线程终止）	    异常被封装在 Future 中（需主动获取）
    核心用途	执行不需要返回结果的任务	            执行需要返回结果或需要处理异常的任务
23.介绍一下synchronized关键字
        原子性：确保临界区代码要么全部执行，要么全部不执行，中间不会被其他线程打断。
        可见性：线程释放锁时，其对共享资源的修改会立即刷新到主内存；其他线程获取锁时，会从主内存加载最新资源状态。
        有序性：通过禁止指令重排序和保证锁的互斥性，确保多线程执行顺序符合预期。
24.介绍一下锁升级机制
        无锁：对象刚刚创建时的状态，没有没任何线程同步。
        偏向锁：当线程第一次获取锁时，通过CAS操作将线程ID记录在对象头的"Mark Word"中，之后该线程再次进入同步块时，无需重新CAS竞争，只需判断对象头的线程ID是否为当前线程。
            是：直接操作资源。
            否：触发偏向锁撤销，升级为轻量级锁。
        轻量级锁(应对短期竞争)：在第二个线程尝试获取资源时，升级为轻量级锁。
            对象尝试获取锁时，会在栈帧中创建"锁记录"，并通过CAS将对象头的Mark Word指向该锁记录。
                CAS成功：线程获取锁，操作资源。
                CAS失败：表示有竞争，线程通过自旋尝试循环获取锁。
            升级触发条件：
                1.自旋次数超过一定阈值（默认10次）。
                2.当前轻量级锁被另一个线程持有。
        重量级锁：依赖操作系统的互斥量，线程获取锁失败会进入阻塞。
25.乐观锁和悲观锁
        悲观锁：每次访问共享资源时，都认为其他线程同时会修改资源。因此，在线程操作资源前需要先获取锁。
            实现方式：synchronized关键字、ReentrantLock等。数据库的行锁、表锁等。
            优点：实现简单，能保证线程的原子性和一致性。
            缺点：锁竞争会导致线程阻塞，增加上下文开销。
                 可能会出现死锁，饥饿等问题。
                 读操作也会加锁，降低并发性能。
        乐观锁：认为并发访问很少发生冲突，因此先操作再验证冲突。
            实现方式：CAS（Compare And Swap）机制、版本号机制等。数据库的MVCC（多版本并发控制）。
            优点：无锁操作，线程不会阻塞，提升并发性能。
                 适合读多写少的场景。
            缺点：实现复杂，可能会导致ABA问题。
                 频繁冲突时，重试开销较大，性能下降。
                 只能保证单个变量的原子性，无法处理复杂操作。
        优先用悲观锁：
            写操作频繁（如库存扣减、转账），冲突概率高；
            操作复杂（多步操作需保证原子性）；
            不希望重试逻辑增加复杂度。
        优先用乐观锁：
            读操作频繁（如查询商品信息），冲突概率低；
            并发量高，希望减少线程阻塞；
            允许短时间的数据不一致（通过重试最终一致）。
26.什么是自旋锁？
        自旋锁是一种非阻塞锁，当线程尝试获取锁时，如果锁被其他线程持有，它不会进入阻塞状态(不会有用户态到内核态的切换)，而是通过循环（自旋）不断尝试获取锁，直到成功为止。
        自旋锁终止条件：
        1.获取到锁
        2.自旋数量达到一定数量
        3.线程被中断
27.ReentrantLock实战（后续补充代码）
    
28.非公平锁
    非公平锁不遵循先到先得，允许刚释放锁的对象优先获取锁。
        案例：线程 A 释放锁后，线程 B（新请求锁）可能比等待队列中的线程 C 先获取到锁。
        优点：吞吐量更高，适合高并发场景。
        synchronized 关键字默认非公平锁，ReentrantLock 默认采用非公平锁。
    更高的吞吐量：
        刚释放锁的线程可能仍在 CPU 上运行，允许其立即重新获取锁可减少线程切换（从阻塞到运行）的开销，提高整体效率。
    减少唤醒延迟：
        避免了公平锁中唤醒等待队列线程的固定开销，适合短时间持有锁的场景。
    缺点:
    可能导致线程饥饿：
        等待队列中的线程可能长期无法获取锁（被新线程持续 “插队”），极端情况下甚至永远无法执行。
    不确定性：
        线程执行顺序不可预测，不适合对执行顺序有严格要求的场景（如资源分配需按申请顺序处理）。
29.可重入锁
    外层代码获得锁之后，内层的递归代码仍然可以获得锁。
    可重入锁的实现机制：
        1.锁计数器：每次线程获取锁时，计数器加1；释放锁时，计数器减1。计数器为0时，锁被释放。
        2.线程标识：记录当前持有锁的线程ID，只有持有锁的线程才能再次获取锁。
    ReentrantLick和synchronized都是可重入锁。

29.公平锁
    公平锁遵循先到先得，线程按请求锁的顺序依次获取锁。
        案例：线程 A 释放锁后，等待队列中的线程 C 会比新请求锁的线程 B 先获取到锁。
        优点：避免线程饥饿，适合对执行顺序有严格要求的场景。
        缺点：吞吐量较低，适合低并发或对公平性要求高的场景。
    保证先来后到：
        通过维护一个等待队列，确保线程按请求顺序获取锁，避免新线程 “插队”。
    减少饥饿风险：
        每个线程最终都能获取到锁，适合资源分配需按申请顺序处理的场景。
    缺点:
    吞吐量较低：
        频繁切换线程和唤醒等待队列线程的开销较大，降低整体效率。
    增加延迟：
        可能导致刚释放锁的线程无法立即重新获取锁，增加等待时间。

30.tryLock,Lock和lockInterrupted的区别
    1.tryLock能获得锁就返回true,不能获得锁就返回false。
    2.lock能获得锁就返回true,否则会等待获取。
    3.lock和lockInterrupted,如果两个线程分别执行这个方法，但此时中断这两个方法，lock不会抛出异常，lockInterrupted方法会抛出异常。

31.ReadWriteLock读写锁
    读操作可以并发执行，写操作必须独占执行。
    读锁（共享锁）：允许多个线程同时获取，适合读取共享资源（无修改操作）。
    写锁（排他锁）：仅允许一个线程获取，适合修改共享资源（如新增、删除、更新）。
        读锁与写锁互斥：读操作时不允许写，写操作时不允许读。
        写锁与写锁互斥：多个线程不能同时执行写操作。
        读锁与读锁兼容：多个线程可以同时执行读操作。
        总结：只有两个都是读，才会共享，其他场景都是排他。
32.什么是锁降级？
    读写锁（如 Java 中的 ReentrantReadWriteLock） 特有的一种机制，指的是 持有 “写锁”（排他锁）的线程，在不释放写锁的前提下，先获取 “读锁”（共享锁），随后再释放写锁 的过程。
    目的是保证数据一致性与共享权限：线程在完成写操作后，释放写锁能够让其他线程读取，从而最大程度保证资源间的可用。
33.共享锁和独占锁
    独占锁：每次只有一个线程能获取锁。避免读写冲突。
    共享锁：允许多个线程获取锁。
34.AQS
35.


    
        
        
        
        

    
    
        



    

