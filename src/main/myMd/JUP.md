//高并发机制题目

1.ThreadLocal的原理和应用场景？
    ThreadLocal是Java中的一个类，它提供了线程局部变量的机制。每个线程都有自己的独立变量副本，互不干扰。
    ThreadLocal通过维护一个Map来存储每个线程的变量副本，键是当前线程，值是该线程的变量副本。
    当调用 threadLocal.set(value) 时，实际是向当前线程的 ThreadLocalMap 中添加键值对（this -> value）。
    由于每个线程的 ThreadLocalMap 是私有变量，不同线程的 ThreadLocal 操作仅影响各自的副本，因此实现了线程间的数据隔离，无需加锁即可保证线程安全。
    ThreadLocalMap 采用线性探测法解决哈希冲突（区别于 HashMap 的链表法），其内部由 Entry 数组实现，Entry 继承自 WeakReference<ThreadLocal>，
    目的是在 ThreadLocal 实例被回收后，自动释放对应的 Entry（减少内存泄漏风险）。
        1.ThreadLocal内维护了一个ThreadLocalMap对象，key 是 ThreadLocal 实例本身，value 是线程要存储的变量副本(不是变量本身)。
        2.ThreadLocalMap 是私有变量，拒绝外部访问。
    注意：
        ThreadLocal 若使用不当，可能导致内存泄漏：
            原因：ThreadLocalMap 的 Entry 中，key 是 ThreadLocal 的弱引用（WeakReference），但 value 是强引用。
            若 ThreadLocal 实例被回收（key 为 null），而线程仍存活（如线程池核心线程），value 会因强引用无法被回收，导致内存泄漏。
        解决方案：
            使用完 ThreadLocal 后，务必调用 remove() 方法清除 value。
            避免使用静态 ThreadLocal 长期持有大对象。
    平时我们写代码会New 一个ThreadLocal对象,但是在SpringBoot里时使用线程池操作。但是操作之后线程池中的资源不会被销毁，会存在引用链。
    GCRoots->Thread-ThreadLocalMap->Entry->key(强引用)->ThreadLocal
                            业务代码：    ThreadLocal 强引用指向上面的ThreadLocal
    就是业务代码设置为null,上述引用链依然存在。此时发生内存泄露。
    如果ThreadLocal是若引用，则会在GC回收的时候直接回收。
    那么ThreadLocal一定会被回收吗？
        不一定，因为ThreadLocalMap的Entry是弱引用，ThreadLocal是强引用，如果ThreadLocal还在使用，那么Entry就不会被回收。
    为什么value不是弱引用？
        因为value是线程要存储的变量副本，如果value是弱引用，那么在GC时可能会被回收，导致线程无法获取到正确的值。
 
2.线性探测法：
        当元素通过哈希函数计算出的目标位置已被占用时，按顺序依次检查后续位置，直到找到空位置完成插入；查找或删除时，也遵循同样的顺序遍历，确保能定位到目标元素。

3.java中实现多线程有几种方法：
        1.继承Thread类
        2.实现Runnable接口
        3.实现Callable接口
        4.使用线程池（Executor框架）
        5.使用ForkJoinPool（适合大任务拆分）
        6.使用CompletableFuture（异步编程）
        7.使用Timer和TimerTask（定时任务）
        8.使用ScheduledExecutorService（定时任务）

4.4种线程池
    1.newFixedThreadPool(int nThreads)：
        创建一个固定大小的线程池，适合处理CPU密集型任务，避免频繁创建销毁线程的开销。
    2.newCachedThreadPool()：
        创建一个可缓存的线程池，适合处理I/O密集型任务，线程数根据需要动态调整，空闲线程60秒后被回收。
    3.newSingleThreadExecutor()：
        创建一个单线程化的线程池，所有任务按顺序执行，适合需要顺序执行任务的场景。
    4.newScheduledThreadPool(int corePoolSize)：
        创建一个支持定时及周期性任务执行的线程池，适合需要定时或周期性执行任务的场景。
5.如何停止一个正在工作的线程？
    1.使用标志位：
        在线程类中定义一个volatile的布尔变量作为标志位，线程在运行时定期检查该标志位，当标志位被设置为false时，线程退出运行。
    2.使用interrupt()方法：
        调用线程的interrupt()方法来中断线程，线程在运行时可以通过检查Thread.interrupted()方法或捕获InterruptedException来响应中断请求并退出。
    3.使用Future的cancel()方法：
        如果线程是通过ExecutorService提交的任务，可以通过Future对象的cancel()方法来取消任务，传入true参数可以尝试中断正在运行的线程。
    4.使用Thread.stop()方法（不推荐）：
        该方法已被弃用，因为它会导致线程在任意位置停止，可能引发数据不一致和资源泄漏问题。
6.notify()和notifyAll()的区别？
    notify()：唤醒一个等待该对象监视器的线程。如果有多个线程在等待，则随机选择一个线程唤醒。被唤醒的线程会继续执行，但需要重新获取对象锁。
    notifyAll()：唤醒所有等待该对象监视器的线程。所有被唤醒的线程会竞争对象锁，只有一个线程能成功获取锁并继续执行，其他线程继续等待。
    总结：
        notify()适用于只需要唤醒一个线程的场景，效率较高，但可能导致某些线程长时间等待。
        notifyAll()适用于需要唤醒所有等待线程的场景，确保所有线程都有机会执行，但效率较低，因为所有线程都会竞争锁。
7.sleep()和wait()的区别？
    1.所属类不同：
        sleep()是Thread类的静态方法，用于让当前线程休眠指定时间。
        wait()是Object类的方法，用于让当前线程等待，直到被notify()或notifyAll()唤醒。
    2.锁的释放：
        sleep()不会释放锁，线程在休眠期间仍然持有对象锁，其他线程无法访问该锁。
        wait()会释放锁，线程进入等待状态后会释放对象锁，允许其他线程访问该锁。
    3.使用场景不同：
        sleep()通常用于控制线程执行的节奏，例如定时任务或轮询操作。
        wait()通常用于线程间通信，等待某个条件满足后再继续执行。
    4.必须在同步块中调用：
        wait()必须在同步块或同步方法中调用，否则会抛出IllegalMonitorStateException异常。
        sleep()可以在任何地方调用，不需要在同步块中。
8.进程和线程的区别？
    程序：程序是一系列静态指令的集合，是保存在介质中的一段程序。
    进程：进程是程序调用的一次执行过程，是系统进行资源分配和调度的一个独立单位。
    线程：线程是CPU执行和调度的一个基本单位。
    简单来说：程序是 “剧本”，进程是 “正在演出的戏剧”，线程是 “戏剧中的角色”—— 剧本（程序）本身不活动，戏剧（进程）是剧本的一次演出过程，而角色（线程）在戏剧中协同完成表演。
9.线程的几种状态
    1.新建状态：当java中New 了一个Thread但是没有调用Start方法时，线程处于新建状态.线程已分配内存，但未进入线程调度队列，不占用 CPU 资源。
    2.就绪状态:调用 start() 方法后，线程进入就绪状态。此时线程已加入调度队列，等待 CPU 分配时间片。
    3.运行状态：就绪状态的线程获得 CPU 时间片后，进入运行状态，执行 run() 方法中的逻辑。
    4.阻塞状态：线程因竞争同步锁失败（如进入 synchronized 代码块但锁被其他线程持有），暂时放弃 CPU 资源，进入阻塞状态。线程不参与 CPU 调度，直到获得同步锁后，才会转为就绪状态；
    阻塞状态仅与 “同步锁竞争” 相关。
    5.等待状态：线程调用 wait() 方法后，进入等待状态，直到其他线程调用 notify() 或 notifyAll() 方法唤醒它。等待状态与 “对象监视器” 相关。
    6.超时等待状态：线程调用带有超时参数的 wait() 方法后，进入超时等待状态。如果在指定时间内未被唤醒，线程会自动转为就绪状态。
    7.终止状态：线程执行完run方法，或者因异常退出，或者被其他线程强制终止，进入终止状态。终止状态的线程不再参与调度，资源会被回收。
10.synchronized可以修饰哪些内容？
    1.修饰非静态方法：修饰当前对象实例。即调用该方法的对象本身。
    2.修饰静态方法：该类所创建的对象使用同一把锁。
    3.修饰代码块：可以指定任意对象作为锁，灵活性更高。通常用于保护临界区代码。代码块内可以有当前实例，类对象，自定义对象。
11.什么是死锁？
    死锁是指两个或多个线程在执行过程中，因争夺资源而造成一种互相等待的现象，从而使得这些线程都无法继续执行下去。
    产生死锁的必要条件：
        1.互斥条件：资源不能被多个线程共享，某个资源一次只能被一个线程占用。
        2.占有且等待条件：一个线程至少持有一个资源，并且等待获取其他线程持有的资源。
        3.不剥夺条件：线程已获得的资源在未使用完之前，不能被强制剥夺，只能由线程自己释放。
        4.循环等待条件：存在一种资源循环等待关系，即线程A等待线程B持有的资源，线程B等待线程C持有的资源，……，最后一个线程又等待线程A持有的资源。
    预防和避免死锁的方法(破坏其中一个条件就可以破坏死锁)：
        1.破坏互斥条件：尽量减少对独占资源的使用，使用读写锁等机制允许多个线程同时访问共享资源。
        2.破坏占有且等待条件：要求线程在请求资源时一次性申请所需的所有资源，避免部分资源被占用而等待其他资源。
        3.破坏不剥夺条件：允许系统强制剥夺某些资源，例如通过超时机制释放长时间未使用的资源。
        4.破坏循环等待条件：为所有资源分配一个唯一编号，要求线程按编号顺序请求资源，避免形成循环等待。
    检测和恢复死锁的方法：
        1.检测死锁：通过定期检查系统状态，识别是否存在死锁情况，例如使用资源分配图等算法。
        2.恢复死锁：一旦检测到死锁，可以通过终止某些线程或回滚某些操作来打破死锁状态，使其他线程能够继续执行。
12.如何确保N个线程访问N个资源又不导致死锁？
        为每个资源分配唯一编号（如 0, 1, 2, ..., N-1）。
        所有线程必须按编号递增的顺序获取资源：无论线程需要哪些资源，都先获取编号小的资源，再获取编号大的资源。
        完成操作后按相反顺序释放资源（先释放大编号资源，再释放小编号资源，顺序不影响死锁预防，但保持一致性更佳）。
        其他措施：
            1.若无法固定顺序（如资源动态生成），可使用ReentrantLock.tryLock(timeout)，超时未获取资源则释放已持有的资源，避免无限等待：
            2.减少锁持有时间： 资源操作完成后立即释放锁，缩短线程持有资源的窗口，降低冲突概率。
            3.监控与告警： 通过jstack定期检查线程状态，若发现阻塞线程持有锁且等待其他锁，及时排查是否存在潜在死锁风险。
13.Java方法可以既是static又是synchronized吗？
        是的，Java 中的方法可以同时被 static 和 synchronized 修饰。这种组合在多线程场景中用于控制对静态资源（属于类的资源，而非实例资源） 的并发访问。
14.什么是thread dump
        thread dump（线程快照）是 Java 虚拟机（JVM）在某一时刻生成的所有线程状态的快照信息，包含线程的执行状态、调用栈、持有的锁、等待的资源等关键数据。
        1.线程基本信息：
            线程 ID（tid）、线程名称（Thread-0、main等）、线程状态（RUNNABLE、BLOCKED等）。
            线程优先级（priority）、是否为守护线程（daemon）。
        2.调用栈（Stack Trace）：
            线程当前执行的方法调用链，从栈顶（当前执行方法）到栈底（初始调用方法），包含类名、方法名、文件名及行号，用于定位线程正在执行的代码。
            锁信息：
                线程持有的锁（locked <0x000000076b7d0000>）。
                线程等待的锁（waiting to lock <0x000000076b7d0000>）。
                死锁信息（若存在死锁，会明确标记哪些线程相互等待）。
        3.JVM 信息：
                生成快照的 JVM 版本、进程 ID（pid）、生成时间等。
15.如何唤醒一个阻塞的线程？
            1.区分线程阻塞的类型
                首先需明确线程为何种原因阻塞（可通过thread dump查看线程状态）：
                BLOCKED状态：线程正在等待获取synchronized锁（因其他线程持有锁未释放）。
                    线程竞争synchronized锁失败，处于阻塞队列中。持有锁的线程释放锁（退出synchronized方法 / 代码块）。
                无需主动唤醒，只需让持有锁的线程尽快执行完同步代码并释放锁，阻塞线程会自动参与锁竞争。
                WAITING状态：线程通过Object.wait()、Thread.join()等方法进入无限期等待，需被其他线程显式唤醒。
                    Object.wait()：释放锁并等待，需通过notify()/notifyAll()唤醒。
                    Thread.join()：等待目标线程执行完毕，需目标线程执行结束。
                    LockSupport.park()：无锁阻塞，需通过LockSupport.unpark(thread)唤醒。
                TIMED_WAITING状态：线程通过Thread.sleep(time)、Object.wait(time)等方法进入限时等待，超时后会自动唤醒，也可被提前唤醒。
                上述三种状态均可通过通过interrupt()中断（需线程响应中断）唤醒。
16.简述Volatile关键字
            是用于保证变量可见性和禁止指令重排序的关键字；不保证原子性。
            核心作用：
                1.当一个变量被volatile修饰后，该变量的变化会立即刷新到主内存，保证变量对其他线程可见。 
                2.volatile通过禁止指令重排序，保证变量的操作执行与顺序。
                3.不保证原子性：当多个线程执行i++的时候，volatile不保证原子性，仍然会出现线程安全问题。
17.单例模式的双重检查(myVolatile.Singleton有相关代码)：
// 双重检查的获取实例方法
                public static Singleton getInstance() {
                    if (instance == null) {
                        synchronized (Singleton.class) {
                    if (instance == null) {
                        instance = new Singleton(); // 初始化对象
                    }
                    }
                    }
                    return instance;
                }
            第一次检查：在加锁前判断对象是否已初始化，若已初始化则直接返回，避免每次访问都加锁（提升性能）。
                    加锁：仅当对象未初始化时，才进入同步代码块（缩小锁范围）。
            第二次检查：在同步代码块内再次判断对象是否已初始化，防止多线程并发进入同步代码块时重复创建对象（保证线程安全）。
            为什么第二次检查要加volatile?
                1.防止指令重排序：在Java中，对象的创建过程可以分为三步：分配内存、初始化对象、将引用指向内存地址。
                由于编译器和处理器可能会对指令进行重排序，导致在多线程环境下，一个线程可能看到一个未完全初始化的对象引用。
                使用volatile关键字可以禁止这种重排序，确保对象在被其他线程看到之前已经完全初始化。
                2.保证可见性：volatile关键字确保当一个线程修改了volatile变量的值，其他线程能够立即看到这个变化。
                在双重检查锁定中，volatile确保当一个线程创建并赋值给实例变量后，其他线程能够立即看到这个已经初始化的实例，而不是看到一个旧的或未初始化的值。 
18.为什么wait和notify方法要在同步代码块中使用？
            wait()和notify()方法是Object类的方法，用于线程间的通信和协调。它们必须在同步代码块或同步方法中使用，原因如下：
                1.锁的持有：wait()方法会释放当前线程持有的对象锁，并使线程进入等待状态，直到被其他线程通过notify()或notifyAll()唤醒。
                如果不在同步代码块中调用wait()，当前线程不会持有对象锁，调用wait()会抛出IllegalMonitorStateException异常。
                2.线程安全：notify()和notifyAll()方法用于唤醒等待该对象监视器的线程。如果不在同步代码块中调用notify()，可能会导致多个线程同时访问共享资源，造成数据不一致或其他并发问题。
                通过在同步代码块中使用，可以确保只有持有对象锁的线程才能调用这些方法，从而保证线程安全。
                3.协调机制：wait()和notify()方法是基于对象监视器（monitor）的协调机制。
                只有在同步代码块中，线程才能正确地与对象监视器交互，实现等待和唤醒的功能。
                4.保证 “检查 - 等待” 逻辑的原子性，避免竞态条件
                线程调用wait方法通常是因为某个条件不满足（如队列为空、资源不足等），需要等待其他线程改变条件后再继续执行。
                而判断该条件的代码通常在代码块中，确保在调用wait之前，线程持有锁并检查条件是原子操作，避免在检查条件和调用wait之间被其他线程修改条件，导致逻辑错误。
19.java中的 interrupted 和 isInterrupted 有什么区别
                背景：线程的 “中断状态” 是一个 boolean 标志，用于表示线程是否被其他线程调用 interrupt() 方法请求中断。
                1.interrupted属于静态方法，而isInterrupted 属于实例方法。
                2.interrupted可以查询当前线程状态，。而isInterrupted可查询指定线程的中断状态。
                3.interrupted会清除中断状态，isInterrupted不会清除中断状态。
20.java中synchronized和 reentrantLock有什么不同
    对比维度	                    synchronized	                                    ReentrantLock
    本质	                        Java 语言关键字	                                    JDK 提供的工具类，依赖 API 实现（Java 代码）
    可重入性	                    支持（同一线程可多次获取锁，自动记录重入次数）	            支持（显式实现可重入，通过 getHoldCount() 查看重入次数）
    锁的释放	                    自动释放（同步块 / 方法执行完毕或抛出异常时）	            必须手动释放（需在 finally 块中调用 unlock()，否则可能导致死锁）
    锁的获取方式	                默认非公平锁（“偏向锁→轻量级锁→重量级锁”，默认非公平）	    支持公平锁和非公平锁（构造函数 ReentrantLock(boolean fair) 指定，默认非公平）
    响应中断	                    不支持（线程获取锁时被阻塞，无法被中断，只能一直等待）	    支持（通过 lockInterruptibly() 方法，可在等待锁时响应中断，避免死等）
    超时获取锁	                不支持（获取不到锁时会一直阻塞）	                        支持（通过 tryLock(long timeout, TimeUnit unit) 实现，超时后放弃获取，避免永久阻塞）
    锁状态查询	                无法直接查询（JVM 内部维护，无对外 API）	                可查询（通过 isLocked()、isHeldByCurrentThread()、getHoldCount() 等方法）
    性能	                        JDK 1.6 后与 synchronized 性能差距缩小
    使用复杂度	                简单（无需手动管理锁的释放，代码简洁）	                    复杂（需手动加锁 / 释放锁，需注意 finally 块的使用，避免遗漏 unlock()）
21.Thread类中的yield方法有什么作用？
    可以暂停当前正在执行的线程对象，并将其状态从运行状态转换为就绪状态，使得线程调度器有机会选择其他同等优先级的线程来执行。
22.java线程池中的submit和execute方法有什么区别？
    对比维度	execute()	                        submit()
    返回值	无返回值（void）	                    有返回值（Future 对象）
    任务类型	仅支持 Runnable 任务	                支持 Runnable 和 Callable 任务
    异常处理	异常直接抛出（若未捕获会导致线程终止）	    异常被封装在 Future 中（需主动获取）
    核心用途	执行不需要返回结果的任务	            执行需要返回结果或需要处理异常的任务
23.介绍一下synchronized关键字
        原子性：确保临界区代码要么全部执行，要么全部不执行，中间不会被其他线程打断。
        可见性：线程释放锁时，其对共享资源的修改会立即刷新到主内存；其他线程获取锁时，会从主内存加载最新资源状态。
        有序性：通过禁止指令重排序和保证锁的互斥性，确保多线程执行顺序符合预期。
24.介绍一下锁升级机制
        无锁：对象刚刚创建时的状态，没有没任何线程同步。
        偏向锁：当线程第一次获取锁时，通过CAS操作将线程ID记录在对象头的"Mark Word"中，之后该线程再次进入同步块时，
        无需重新CAS竞争，只需判断对象头的线程ID是否为当前线程。
            是：直接操作资源。
            否：触发偏向锁撤销，升级为轻量级锁。
        轻量级锁(应对短期竞争)：在第二个线程尝试获取资源时，升级为轻量级锁。
            对象尝试获取锁时，会在栈帧中创建"锁记录"，并通过CAS将对象头的Mark Word指向该锁记录。
                CAS成功：线程获取锁，操作资源。
                CAS失败：表示有竞争，线程通过自旋尝试循环获取锁。
            升级触发条件：
                1.自旋次数超过一定阈值（默认10次）。
                2.当前轻量级锁被另一个线程持有。
        重量级锁：依赖操作系统的互斥量，线程获取锁失败会进入阻塞。
25.乐观锁和悲观锁
        悲观锁：每次访问共享资源时，都认为其他线程同时会修改资源。因此，在线程操作资源前需要先获取锁。
            实现方式：synchronized关键字、ReentrantLock等。数据库的行锁、表锁等。
            优点：实现简单，能保证线程的原子性和一致性。
            缺点：锁竞争会导致线程阻塞，增加上下文开销。
                 可能会出现死锁，饥饿等问题。
                 读操作也会加锁，降低并发性能。
        乐观锁：认为并发访问很少发生冲突，因此先操作再验证冲突。
            实现方式：CAS（Compare And Swap）机制、版本号机制等。数据库的MVCC（多版本并发控制）。
            优点：无锁操作，线程不会阻塞，提升并发性能。
                 适合读多写少的场景。
            缺点：实现复杂，可能会导致ABA问题。
                 频繁冲突时，重试开销较大，性能下降。
                 只能保证单个变量的原子性，无法处理复杂操作。
        优先用悲观锁：
            写操作频繁（如库存扣减、转账），冲突概率高；
            操作复杂（多步操作需保证原子性）；
            不希望重试逻辑增加复杂度。
        优先用乐观锁：
            读操作频繁（如查询商品信息），冲突概率低；
            并发量高，希望减少线程阻塞；
            允许短时间的数据不一致（通过重试最终一致）。
26.什么是自旋锁？
        自旋锁是一种非阻塞锁，当线程尝试获取锁时，如果锁被其他线程持有，
        它不会进入阻塞状态(不会有用户态到内核态的切换)，而是通过循环（自旋）不断尝试获取锁，直到成功为止。
        自旋锁终止条件：
        1.获取到锁
        2.自旋数量达到一定数量
        3.线程被中断
27.ReentrantLock实战（后续补充代码）
    
28.非公平锁
    非公平锁不遵循先到先得，允许刚释放锁的对象优先获取锁。
        案例：线程 A 释放锁后，线程 B（新请求锁）可能比等待队列中的线程 C 先获取到锁。
        优点：吞吐量更高，适合高并发场景。
        synchronized 关键字默认非公平锁，ReentrantLock 默认采用非公平锁。
    更高的吞吐量：
        刚释放锁的线程可能仍在 CPU 上运行，允许其立即重新获取锁可减少线程切换（从阻塞到运行）的开销，提高整体效率。
    减少唤醒延迟：
        避免了公平锁中唤醒等待队列线程的固定开销，适合短时间持有锁的场景。
    缺点:
    可能导致线程饥饿：
        等待队列中的线程可能长期无法获取锁（被新线程持续 “插队”），极端情况下甚至永远无法执行。
    不确定性：
        线程执行顺序不可预测，不适合对执行顺序有严格要求的场景（如资源分配需按申请顺序处理）。
29.可重入锁
    外层代码获得锁之后，内层的递归代码仍然可以获得锁。
    可重入锁的实现机制：
        1.锁计数器：每次线程获取锁时，计数器加1；释放锁时，计数器减1。计数器为0时，锁被释放。
        2.线程标识：记录当前持有锁的线程ID，只有持有锁的线程才能再次获取锁。
    ReentrantLick和synchronized都是可重入锁。

29.公平锁
    公平锁遵循先到先得，线程按请求锁的顺序依次获取锁。
        案例：线程 A 释放锁后，等待队列中的线程 C 会比新请求锁的线程 B 先获取到锁。
        优点：避免线程饥饿，适合对执行顺序有严格要求的场景。
        缺点：吞吐量较低，适合低并发或对公平性要求高的场景。
    保证先来后到：
        通过维护一个等待队列，确保线程按请求顺序获取锁，避免新线程 “插队”。
    减少饥饿风险：
        每个线程最终都能获取到锁，适合资源分配需按申请顺序处理的场景。
    缺点:
    吞吐量较低：
        频繁切换线程和唤醒等待队列线程的开销较大，降低整体效率。
    增加延迟：
        可能导致刚释放锁的线程无法立即重新获取锁，增加等待时间。

30.tryLock,Lock和lockInterrupted的区别
    1.tryLock能获得锁就返回true,不能获得锁就返回false。
    2.lock能获得锁就返回true,否则会等待获取。
    3.lock和lockInterrupted,如果两个线程分别执行这个方法，但此时中断这两个方法，lock不会抛出异常，lockInterrupted方法会抛出异常。

31.ReadWriteLock读写锁
    读操作可以并发执行，写操作必须独占执行。
    读锁（共享锁）：允许多个线程同时获取，适合读取共享资源（无修改操作）。
    写锁（排他锁）：仅允许一个线程获取，适合修改共享资源（如新增、删除、更新）。
        读锁与写锁互斥：读操作时不允许写，写操作时不允许读。
        写锁与写锁互斥：多个线程不能同时执行写操作。
        读锁与读锁兼容：多个线程可以同时执行读操作。
        总结：只有两个都是读，才会共享，其他场景都是排他。
32.什么是锁降级？
    读写锁（如 Java 中的 ReentrantReadWriteLock） 特有的一种机制，指的是 持有 “写锁”（排他锁）的线程，
    在不释放写锁的前提下，先获取 “读锁”（共享锁），随后再释放写锁 的过程。
    目的是保证数据一致性与共享权限：线程在完成写操作后，释放写锁能够让其他线程读取，从而最大程度保证资源间的可用。
33.共享锁和独占锁
    独占锁：每次只有一个线程能获取锁。避免读写冲突。
    共享锁：允许多个线程获取锁。
34.AQS
35.JAVA中i++操作是线程安全的吗？
    不是线程安全的。
    i++操作可以分解为三个步骤：
        1.读取变量i的值到CPU寄存器中。
        2.对寄存器中的值加1。
        3.将寄存器中的值写回变量i。
    在多线程环境下，多个线程可能同时执行i++操作，导致以下问题：
        1.读取冲突：多个线程同时读取变量i的值，可能读取到相同的值。
        2.写入冲突：多个线程同时将计算结果写回变量i，可能覆盖其他线程的更新。
    例如：
        假设变量i初始值为0，两个线程A和B同时执行i++操作。
        1.线程A读取i的值（0）到寄存器。
        2.线程B读取i的值（0）到寄存器。
        3.线程A对寄存器中的值加1，得到1。
        4.线程B对寄存器中的值加1，得到1。
        5.线程A将1写回变量i。
        6.线程B将1写回变量i。
    最终变量i的值为1，而不是预期的2，导致数据不一致的问题。
    为了保证i++操作的原子性，可以使用以下方法：
        1.synchronized关键字：将i++操作放在同步代码块或同步方法中，确保同一时间只有一个线程执行该操作。
        2.ReentrantLock：使用显式锁来保护i++操作，确保线程安全。
        3.AtomicInteger类：使用java.util.concurrent.atomic包中的AtomicInteger类，它提供了原子性的incrementAndGet()方法来实现线程安全的自增操作。    
39.JAVA哪些集合是线程安全的？
    1.HsahTable
    2.Collections.synchronizedXXX包装的集合
        List<String> syncList = Collections.synchronizedList(new ArrayList<>());
        Map<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());
    3.JUC并发的集合
        ConcurrentHashMap
            JDK 1.7：采用 “分段锁（Segment）”，将数据分为多个段，每个段独立加锁，支持多线程同时操作不同段，并发度高。
            JDK 1.8：取消分段锁，改用 CAS + synchronized 优化，粒度更细，性能进一步提升。
            支持 null 值（与 Hashtable 不同），提供原子操作方法（如 putIfAbsent()）。
        CopyOnWriteArrayList
            适合读多写少的场景，写操作时会复制底层数组，读操作不加锁，性能优越。
        ConcurrentSkipListMap 与 ConcurrentSkipListSet
            基于跳表实现的有序集合，分别对应 TreeMap 和 TreeSet 的线程安全版本。
40.既然start方法会调用run方法，那为什么不直接使用run方法？
        run方只是执行代码的逻辑，没有创建新的线程，而start方法会创建一个新的线程，并在新线程中调用run方法。
41.简述synchronized的原理
        synchronized 是 Java 提供的一种内置锁机制，用于实现线程间的同步，确保多个线程在访问共享资源时不会发生冲突。其原理主要包括以下几个方面：
            1.对象头（Object Header）：每个 Java 对象都有一个对象头，其中包含了锁信息（如锁标志位、线程 ID、锁记录等）。
                synchronized 通过修改对象头的信息来实现锁的获取和释放。
            2.锁的状态：synchronized 锁有三种状态：无锁、偏向锁、轻量级锁和重量级锁。根据竞争情况，JVM 会动态地将锁从一种状态升级到另一种状态，以提高性能。
                无锁：对象刚创建时的状态，没有任何线程持有锁。
                偏向锁：当一个线程第一次获取锁时，JVM 会将对象头中的线程 ID 设置为该线程的 ID，表示该线程偏向于这个锁。后续该线程再次获取该锁时，无需竞争，直接进入临界区。
                轻量级锁：当另一个线程尝试获取偏向锁时，JVM 会将偏向锁升级为轻量级锁。轻量级锁使用 CAS（Compare And Swap）操作来尝试获取锁，如果失败则进入自旋等待。
                重量级锁：如果自旋等待多次仍未能获取到轻量级锁，JVM 会将其升级为重量级锁，此时线程会进入阻塞状态，等待操作系统调度。
            3.监视器（Monitor）：每个对象都有一个与之关联的监视器，当线程进入 synchronized 块或方法时，会尝试获取该对象的监视器。
                如果成功，线程就可以执行临界区代码；否则，线程会被阻塞，直到监视器被释放。
            4.内存模型：synchronized 保证了可见性和有序性。当一个线程释放锁时，它对共享变量的修改会被刷新到主内存；
            当另一个线程获取同一把锁时，它会从主内存中重新加载这些变量，确保看到的是最新的值。此外，synchronized 还禁止指令重排序，确保代码执行顺序符合预期。
        总结：synchronized 通过对象头的锁信息、锁的状态转换、监视器机制以及内存模型的保证，实现了线程间的同步和互斥，确保共享资源在多线程环境下的安全访问。
43.什么是锁消除和锁粗化？
        锁消除：JVM在编译时，通过逃逸分析来判定有些锁不存在竞争风险，所以自动消除这些锁，减少了操作的损耗。
        锁粗化：JVM 将多个连续的、对同一把锁的细粒度加锁 / 解锁操作，合并为一次范围更大的粗粒度加锁 / 解锁，减少锁操作的次数。
44.简述Synchronized和ReentrantLock的不同。
        1.二者都支持非公平锁，但ReentrantLock还支持公平锁。
        2.synchronized是java关键字，ReentrantLock是JUP包下的一个类。
        3.synchronized不需要手动释放锁，ReentrantLock需要手动释放锁。
        4.synchronized基于java的Monitorl来实现锁机制，而ReentrantLock基于AQS。
        5.ReentrantLock可以中断响应，而synchronized不可以。
    场景选择：   
    优先使用 synchronized：
        简单同步场景（如单方法 / 代码块同步）；
        希望减少代码复杂度（无需手动管理锁释放）；
        团队对 ReentrantLock 不熟悉，避免误用导致锁泄漏。
    优先使用 ReentrantLock：
        需要公平锁（避免线程饥饿）；
        需要中断响应、超时机制（防止死锁）；
        需要多条件唤醒（精确控制线程协作）；
        需要查询锁状态（监控或调试）。
45.简述AQS框架
        ReentrantLock,CountDownLatch和Semaphore等都是基于AQS实现的。
        AQS包含：
            1.states是int类型的成员变量，用来表示同步的状态，用volatile修饰，
            2.双向等待队列，将每个线程封装成节点，先进先出。来抢资源时，如果抢不到，就会添加到链表尾，资源空闲又会唤醒头节点。
            加锁过程：如果线程1已经获取锁，那么当线程2获取锁的时候，会CAS尝试将state从0变成1,如果成功就获取锁，失败就加入等待队列。队列创建时会先创建一个空的节点，使head节点(头节点)指向这个节点，
            之后再创建尾节点，使尾节点指向node2节点。并使空节点指向线程2的节点(效果如：head->空节点->线程2节点->tail节点)。
            加入队列后，会检查一次状态，如果线程的前一个节点是头节点，那么就尝试获取锁，如果获取成功，就把头节点指向当前节点，并把前一个节点的next指向null(效果如：head->线程2节点->tail节点)，
            如果获取失败，那就调用LockSupport.park方法，挂起线程。从此线程2算是挂起在队列里了。
            释放锁过程：线程1 释放锁的时候，会检查 exclusiveOwnerThread 是不是自己的线程，是的话会将state变量修改为0，接着把exclusiveOwnerThread变量修改为空，
            接着判断头节点是否存在，如果存在，则调用LockSupport.unlock唤醒头节点的后续节点(线程2节点)，这里解锁流程就结束了。
            线程唤醒流程：线程唤醒之后会先获取到前序节点，如果前序节点是头节点，那么先判断state变量，如果是0，那么就用CAS吧state改成1。接着把 exclusiveOwnerThread变量设置为线程2。
            此时线程2为头节点，且state变量为1，线程2就可以执行临界区代码了。
            公平锁和非公平锁的区别：
                在AQS中，在公平锁下，如果线程3想要获取锁，则需要判断头节点有没有后续节点，如果有后续节点且后续节点的线程不是自己，那么就加入等待队列。
                        在非公平锁下，线程3想要获取锁时，不需要判断头节点有没有后续节点，直接CAS尝试获取锁，如果失败就加入等待队列
            为什么使用双向链表呢？
                    1.如果有线程取消，那么使用双向链表删除更方便。(对于单向链表，删除一个节点需要从头遍历到该节点才能删除，时间复杂度为O(n),
                    2.便于唤醒后继节点：正常情况下链表会唤醒后继节点，但是后继节点可能由于某些原因唤醒失败，此时需要重新找到前驱节点。
                而双向链表可以直接通过前驱节点删除，时间复杂度为O(1))。
            不同工具的state标示的含义是不同的，ReentrantLock中state为1时说明当前对象锁已经被占有，其他线程来加锁会进入state队列中。
                Semaphore中state表示当前可用的许可证数量。
                CountDownLatch中state表示当前计数器的值。
            AQS如何实现共享锁？
                通过states实现，可以定义states为共享线程的数目，当线程获取锁时，states-1,释放锁时，states+1,当states为0时，表示没有线程持有锁。
46.介绍下ReentrantLock的tryLock,lock,acquire,tryAcquire方法：
        1.lock方法：获取锁，如果锁被其他线程持有，则当前线程会被阻塞，直到获取到锁为止。
        2.tryLock方法：尝试获取锁，如果锁被其他线程持有，则立即返回false，不会阻塞当前线程。
        3.acquire方法：是AQS中的方法，用于获取独占锁。它会调用tryAcquire方法尝试获取锁，如果获取失败，则将当前线程加入等待队列并阻塞，直到获取到锁为止。
        4.tryAcquire方法：是AQS中的方法，用于尝试获取独占锁。它会检查当前锁的状态，如果锁未被持有，则将状态设置为已持有并返回true；否则返回false。
    速记：没有try的都是失败了添加队列。
47.Java有哪些同步器？
    1.独占锁同步器
        1.ReentrantLock
        2.ReentrantLockReadWriteBarrier
    2.共享锁同步器
        1.Semaphore
        2.CountDownLatch
        3.CyclicBarrier
        4.Phaser
48.Java中线程池如何实现？
        线程池的创建依赖以下组件：
            1.线程池管理器：负责线程池的销毁，控制线程数量，任务队列等参数。
            2.工作线程：线程池中的核心线程，执行完成之后不销毁，而是循环获取新任务。
            3.任务队列：存放正在等待的任务，当线程都在忙碌时，新任务会进入队列等待。
            4.任务接口：定义线程需要执行的逻辑，Runnable无返回值，Callable有返回值。
        ThreadPoolExector的核心参数：
            核心线程数，最大线程数，临时线程空闲存活时间，临时线程空闲存活时间的单位，任务队列，线程工厂，拒绝策略。
        线程池的执行流程：   
            1.当有新任务提交时，线程池会先判断当前运行的线程数是否小于核心线程数。
                是：创建一个新的工作线程来执行任务。
                否：将任务放入任务队列中等待。
            2.如果任务队列已满且当前运行的线程数小于最大线程数，则创建新的临时线程来处理任务。
            3.如果任务队列已满且当前运行的线程数已达最大线程数，则根据拒绝策略处理新任务。
            4.当工作线程完成任务后，会从任务队列中获取下一个任务继续执行。如果没有任务可执行，临时线程会在空闲存活时间后被销毁，而核心线程则会一直保留。
        线程池的状态：
            1.RUNNING：线程池正常运行，可以接受新任务并处理队列中的任务。
            2.SHUTDOWN：调用shutdown()方法后，线程池进入该状态，不再接受新任务，但会继续处理队列中的任务。
            3.STOP：调用shutdownNow()方法后，线程池进入该状态，不再接受新任务，并尝试停止正在执行的任务，同时清空任务队列。
            4.TIDYING：当所有任务都已完成且线程池中的工作线程数为0时，线程池进入该状态，准备终止。
            5.TERMINATED：线程池完全终止，所有资源被释放。
        线程池的生命周期：
            1.创建线程池：通过ThreadPoolExecutor的构造方法创建线程池实例，初始化核心参数。
            2.提交任务：通过execute()或submit()方法将任务提交到线程池。
            3.任务执行：线程池根据当前状态和参数决定如何处理新任务（创建新线程、入队等待、拒绝等）。
            4.关闭线程池：调用shutdown()或shutdownNow()方法，进入相应的关闭状态，停止接受新任务并处理现有任务。
            5.资源释放：当所有任务完成且线程池终止后，释放相关资源。
        线程池的拒绝策略有哪些：
            1.AbortPolicy（默认）：直接抛出 RejectedExecutionException 异常，阻止系统正常运行。
            2.CallerRunsPolicy：调用者线程自己执行任务，降低新任务提交速度。
            3.DiscardPolicy：直接丢弃新任务，不抛出异常。
            4.DiscardOldestPolicy：丢弃队列中最旧的任务，然后尝试提交新任务。
        线程池分为几种：
            1.FixedThreadPool：固定大小线程池，核心线程数和最大线程数相同，适合负载较稳定的场景。
            2.CachedThreadPool：可缓存线程池，核心线程数为0，最大线程数为 Integer.MAX_VALUE，适合任务量波动较大的场景。
            3.SingleThreadExecutor：单线程化线程池，只有一个工作线程，适合需要顺序执行任务的场景。
            4.ScheduledThreadPool：支持定时和周期性任务执行的线程池，适合需要定时任务的场景。
        
49.JAVA中的阻塞队列：
        1.java中的阻塞队列是一种支持阻塞插入和阻塞移除的队列数据结构。核心特性是：队列满时，生产者线程会被阻塞，队列空时，消费者线程会被阻塞。
    操作类型	        插入元素（队列满时）	        移除元素（队列空时）	    检查元素（队列空时）
    抛出异常	        add(e)	remove()	        element()
    返回特殊值	    offer(e)（返回 false）	    poll()（返回 null）	    peek()（返回 null）
    阻塞等待	        put(e)	                    take()	                -
    超时等待	        offer(e, timeout, unit)	    poll(timeout, unit)	    -

50.JAVA中的阻塞队列有哪些？
        1.ArrayBlockingQueue：基于数组的有界阻塞队列，先进先出（FIFO）原则，适合生产者消费者模型。
        2.LinkedBlockingQueue：基于链表的可选界限阻塞队列，默认无界，适合高并发场景。
        3.PriorityBlockingQueue：基于优先级堆的无界阻塞队列，元素按优先级排序，适合任务优先级调度。
        4.DelayQueue：基于优先级堆的无界阻塞队列，元素在指定延迟时间后才能被取出，适合定时任务调度。
        5.SynchronousQueue：不存储元素的阻塞队列，每个插入操作必须等待对应的移除操作，适合直接交互场景。
        6.LinkedTransferQueue：基于链表的无界阻塞队列，支持生产者直接将元素传递给消费者，适合高吞吐量场景。
        7.LinkedBlockingDeque：基于链表的双端阻塞队列，支持从两端插入和移除元素，适合需要双向访问的场景。
51.java中守护线程和本地线程的区别？
        守护线程（Daemon Thread）：
            1.守护线程是为其他线程提供服务的线程，通常用于执行后台任务，如垃圾回收、日志记录等。
            2.守护线程的生命周期依赖于用户线程（非守护线程）。当所有用户线程结束时，JVM 会自动终止所有守护线程。
            3.可以通过调用 Thread 类的 setDaemon(true) 方法将一个线程设置为守护线程。必须在启动线程之前设置，否则会抛出 IllegalThreadStateException 异常。
            4.守护线程不适合执行需要确保完成的任务，因为它们可能在用户线程结束时被强制终止。
        用户线程（User Thread）：
            1.用户线程是执行应用程序逻辑的主要线程，通常用于处理业务逻辑、用户请求等。
            2.用户线程的生命周期独立于其他用户线程和守护线程。JVM 会一直运行，直到所有用户线程都结束。
            3.默认情况下，创建的线程都是用户线程，除非显式将其设置为守护线程。
            4.用户线程适合执行需要确保完成的任务，因为它们不会被 JVM 强制终止，除非程序显式退出或所有用户线程结束。
        总结：
            守护线程用于后台服务，其生命周期依赖于用户线程；用户线程用于执行主要任务，其生命周期独立且持续到所有用户任务完成。
52.什么是死锁和活锁，饥饿？
        死锁是指两个或锁哥线程相互争夺资源而导致的锁。
        活锁是线程没有被阻塞，但是一直在重复某个动作，导致无法继续执行下去。(所以活锁的状态是不断改变的)。
        饥饿是指一个或多个线程没有获得想要的资源，因而无法执行下去。
        JAVA中导致饥饿的原因？
            1.线程优先级过低，导致高优先级线程一直占用CPU资源。
            2.锁竞争激烈，某些线程长时间无法获取锁。
            3.不公平的锁机制，某些线程被频繁 “插队”。
            4.资源分配不均，某些线程长期得不到所需资源。
            5.线程调度算法不合理，导致某些线程长期处于等待状态。
53.JAVA中exector和exectors的区别？
        Executor是一个接口，定义了执行任务的标准方法execute(Runnable command)，是线程池的顶层设计。
        Executors是一个工具类，提供了创建各种类型线程池的静态工厂方法，如newFixedThreadPool、newCachedThreadPool等，简化了线程池的创建过程。
        总结：Executor是接口，定义了线程池的行为；Executors是工具类，提供了便捷的线程池创建方法。
54.什么是原子操作？在JAVA中有哪些原子操作的工具类？
        原子操作是指不可分割的操作，要么全部执行成功，要么全部不执行，不会被线程调度机制中断。原子操作确保在多线程环境下，数据的一致性和完整性。
        JAVA中常用的原子操作工具类包括：
            1.AtomicInteger：提供对整数类型的原子操作，如incrementAndGet()、decrementAndGet()等。
            2.AtomicLong：提供对长整数类型的原子操作，类似于AtomicInteger。
            3.AtomicBoolean：提供对布尔类型的原子操作，如compareAndSet()等。
            4.AtomicReference：提供对对象引用的原子操作，可以用于实现无锁数据结构。
            5.AtomicStampedReference：类似于AtomicReference，但增加了版本号，防止ABA问题。
            6.AtomicMarkableReference：类似于AtomicReference，但增加了标记位，用于表示对象状态。
            7.LongAdder和DoubleAdder：用于高并发场景下的累加操作，性能优于AtomicLong和AtomicDouble。
        这些类都位于java.util.concurrent.atomic包中，利用底层的CAS（Compare-And-Swap）机制实现高效的原子操作，适用于多线程环境下的数据共享和更新。
55.什么是Callable和Future？
        Callable是一个接口，类似于Runnable，但它可以返回结果并且可以抛出异常。Callable接口定义了一个call()方法，执行任务时会返回一个结果。
        Future是一个接口，表示异步计算的结果。通过Future对象，可以检查任务是否完成、获取任务的结果，或者取消任务。
        Future接口提供了get()方法来获取结果，如果任务尚未完成，get()方法会阻塞直到结果可用。
        通常，Callable和Future一起使用，通过ExecutorService提交Callable任务，返回一个Future对象，用于获取任务的执行结果。
56.什么是FutureTask？
        FutureTask是一个实现了Runnable和Future接口的类，表示一个可以取消的异步计算任务。它可以包装一个Callable或Runnable对象，并在执行时返回计算结果。
        FutureTask的主要功能包括：
            1.任务执行：可以通过ExecutorService提交FutureTask��执行其中封装的Callable或Runnable任务。
            2.结果获取：通过调用get()方法，可以获取任务的执行结果。如果任务尚未完成，get()方法会阻塞直到结果可用。
            3.任务取消：可以通过调用cancel()方法取消任务，如果任务尚未开始执行，则不会执行；如果任务正在执行，则尝试中断任务。
            4.状态检查：可以通过isDone()方法检查任务是否已完成，通过isCancelled()方法检查任务是否已被取消。
        FutureTask适用于需要在多线程环境下执行异步任务并获取结果的场景，提供了便捷的方式来管理和控制任务的生命周期。
57.在JAVA中CylicBarrier和CountdownLatch有什么区别？
        1.功能不同：
            CountDownLatch用于等待一组线程完成某些操作后再继续执行，适合一次性事件的等待。
            CyclicBarrier用于让一组线程在某个点上相互等待，直到所有线程都到达该点后再继续执行，适合多次重复的同步点。
        2.重用性：
            CountDownLatch是一次性的，计数器只能使用一次，不能重置。
            CyclicBarrier是可重用的，可以在达到屏障点后重置，允许线程多次等待。
        3.使用场景：
            CountDownLatch适用于需要等待多个线程完成任务后再继续的场景，如等待多个服务启动完成。
            CyclicBarrier适用于需要多个线程在某个阶段同步后再继续的场景，如多线程计算分阶段结果。
        4.构造参数：
            CountDownLatch通过传入一个初始计数值来创建，表示需要等待的线程数量。
            CyclicBarrier通过传入一个参与线程数量和一个可选的屏障动作（Runnable）来创建，表示需要等待的线程数量和屏障点到达时执行的动作。
        总结：CountDownLatch用于一次性等待多个线程完成任务，而CyclicBarrier用于多次同步多个线程在某个点上。
58.什么是线程本地存储（ThreadLocal）？ 
        线程本地存储（ThreadLocal）是Java提供的一种机制，允许每个线程拥有独立的变量副本，从而避免多线程环境下的共享变量冲突。每个线程通过ThreadLocal对象访问自己的变量副本，互不干扰。
        ThreadLocal的主要特点包括：
            1.独立性：每个线程都有自己的变量副本，修改不会影响其他线程。
            2.简化代码：避免了显式的同步操作，减少了锁的使用，提高了代码的可读性和维护性。
            3.适用场景：适用于需要在多个方法或类中传递数据，但又不希望这些数据被其他线程访问的场景，如用户会话信息、数据库连接等。
        使用ThreadLocal的步骤：
            1.创建ThreadLocal对象：定义一个ThreadLocal变量，用于存储线程特有的数据。
            2.设置值：通过set()方法为当前线程设置变量值。
            3.获取值：通过get()方法获取当前线程的变量值。
            4.清理资源：使用remove()方法清除当前线程的变量值，防止内存泄漏。
        示例代码：
            ThreadLocal<Integer> threadLocal = new ThreadLocal<>();
            threadLocal.set(100); // 设置当前线程的值
            Integer value = threadLocal.get(); // 获取当前线程的值
            threadLocal.remove(); // 清除当前线程的值
        总结：ThreadLocal提供了一种简便的方法来实现线程局部变量，确保每个线程拥有独立的数据副本，避免了多线程环境下的数据冲突和同步问题。
59.简述Java内存模型（JMM）
        Java内存模型（Java Memory Model，JMM）是Java虚拟机规范的一部分，定义了Java程序中变量的访问规则以及线程之间的交互方式。JMM旨在解决多线程环境下的内存可见性、原子性和有序性问题，确保程序在不同平台和硬件架构上具有一致的行为。
        JMM的核心概念包括：
            1.主内存和工作内存：每个线程都有自己的工作内存，存储该线程使用的变量副本。所有线程共享一个主内存，存储所有变量的实际值。线程对变量的读写操作首先在工作内存中进行，然后通过同步机制将变化刷新到主内存。
            2.可见性：当一个线程修改了共享变量的值，其他线程可能无法立即看到这个变化。JMM通过同步机制（如synchronized、volatile等）来保证变量的可见性。
            3.原子性：某些操作需要作为一个不可分割的整体执行，JMM通过锁机制（如synchronized、ReentrantLock等）来保证操作的原子性。
            4.有序性：为了提高性能，编译器和处理器可能会对指令进行重排序。JMM通过内存屏障（Memory Barrier）和happens-before规则来保证程序执行的有序性。
        JMM中的happens-before规则定义了操作之间的先后关系，包括：
            1.程序顺序规则：一个线程内，按代码顺序执行的操作，前面的操作happens-before后面的操作。
            2.监视器锁规则：对同一个锁的解锁操作happens-before后续对该锁的加锁操作。
            3.volatile变量规则：对一个volatile变量的写操作happens-before后续对该变量的读操作。
            4.传递性：如果A happens-before B，且B happens-before C，则A happens-before C。
        总结：Java内存模型通过定义主内存和工作内存、可见性、原子性和有序性等概念，以及happens-before规则，确保多线程环境下程序的正确性和一致性，为开发高效、安全的
        并发应用提供了理论基础。
60.简述Java中的锁优化技术
        Java中的锁优化技术主要包括以下几种：
            1.偏向锁（Biased Locking）：偏向锁是一种轻量级的锁优化机制，适用于单线程访问的场景。当一个线程第一次获取锁时，JVM会将锁标记为偏向该线程，后续该线程再次获取该锁时，无需进行任何同步操作，直接进入临界区，从而减少了锁的竞争和开销。
            2.轻量级锁（Lightweight Locking）：当多个线程竞争同一把偏向锁时，JVM会将偏向锁升级为轻量级锁。轻量级锁使用CAS（Compare-And-Swap）操作来尝试获取锁，如果获取失败，线程会进入自旋状态，等待一段时间后再次尝试获取锁，从而避免了线程阻塞和上下文切换的开销。
            3.重量级锁（Heavyweight Locking）：当轻量级锁竞争激烈且自旋次数超过一定阈值时，JVM会将轻量级锁升级为重量级锁。重量级锁使用操作系统的互斥机制（如Mutex）来实现线程间的同步，当一个线程获取到重量级锁时，其他线程会被阻塞，直到锁被释放。
            4.锁消除（Lock Elimination）：JVM通过逃逸分析来判断某些对象的锁是否存在竞争风险，如果确定某个对象的锁不会被其他线程访问，JVM会自动消除该对象的锁，从而减少不必要的同步开销。
            5.锁粗化（Lock Coarsening）：JVM会将多个连续的、对同一把锁的细粒度加锁/解锁操作合并为一次范围更大的粗粒度加锁/解锁操作，从而减少锁操作的次数，提高性能。
        这些锁优化技术通过减少不必要的同步操作、降低线程竞争和上下文切换的开销，提高了Java程序在多线程环境下的执行效率和性能。开发者可以通过合理使用synchronized关键字和选择合适的并发工具类（如ReentrantLock）来充分利用这些优化技术。
61.简述Java中的线程调度
        Java中的线程调度是指操作系统和Java虚拟机（JVM）共同管理和分配CPU资源给多个线程的过程。线程调度的主要目标是确保多线程程序能够高效地运行，同时保证线程之间的公平性和响应性。
        Java中的线程调度主要依赖于以下几个方面：
            1.线程优先级（Thread Priority）：Java中的每个线程都有一个优先级，范围从1（最低）到10（最高），默认优先级为5。线程调度器通常会优先选择高优先级的线程执行，但这并不保证高优先级线程一定会先执行，因为具体的调度策略取决于操作系统。
            2.时间片轮转（Time Slicing）：大多数操作系统采用时间片轮转的调度策略，即每个线程被分配一个固定的时间片，在时间片内可以执行任务。当时间片用完后，调度器会将CPU资源分配给下一个等待的线程，从而实现多线程的并发执行。
            3.阻塞与唤醒（Blocking and Waking Up）：当一个线程执行阻塞操作（如I/O操作、等待锁等）时，调度器会将该线程挂起，并将CPU资源分配给其他可运行的线程。当阻塞条件解除时，调度器会唤醒该线程，使其重新进入就绪状态，等待下一次调度。
            4.守护线程与用户线程（Daemon Threads and User Threads）：Java中的线程分为守护线程和用户线程。守护线程是为其他线程提供服务的后台线程，当所有用户线程结束时，JVM会自动终止所有守护线程。用户线程则是执行应用程序逻辑的主要线程，JVM会一直运行，直到所有用户线程都结束。
            5.同步与锁机制（Synchronization and Locking）：Java提供了多种同步机制（如synchronized关键字、ReentrantLock等）来控制多个线程对共享资源的访问。这些机制确保了在多线程环境下数据的一致性和完整性，但也可能导致线程阻塞，从而影响调度效率。
        总结：Java中的线程调度通过优先级、时间片轮转、阻塞与唤醒、守护线程与用户线程以及同步与锁机制等多方面的协同工作，实现了多线程程序的高效运行和资源管理。开发者需要理解这些调度机制，以编写高性能的并发应用程序。
62.简述Java中的线程池
        Java中的线程池是一种管理和复用线程的机制，旨在提高多线程应用程序的性能和资源利用率。通过线程池，应用程序可以避免频繁创建和销毁线程的开销，从而减少系统资源的消耗和提高响应速度。
        Java中的线程池主要由以下几个核心组件组成：
            1.线程池管理器（ThreadPoolExecutor）：负责管理线程池的生命周期，包括创建、调度和销毁线程。ThreadPoolExecutor类提供了丰富的配置选项，如核心线程数、最大线程数、线程空闲时间、任务队列类型等。
            2.工作线程（Worker Threads）：线程池中的核心线程，负责执行提交的任务。工作线程在完成任务后不会被销毁，而是返回到线程池中等待新的任务，从而实现线程的复用。
            3.任务队列（Task Queue）：用于存储等待执行的任务。当所有工作线程都在忙碌时，新提交的任务会被放入任务队列中，等待空闲的工作线程来处理。
            4.任务接口（Runnable和Callable）：定义了任务的执行逻辑。Runnable接口适用于不需要返回结果的任务，而Callable接口适用于需要返回结果或抛出异常的任务。
        线程池的工作流程如下：
            1.任务提交：通过ExecutorService接口的execute()或submit()方法将任务提交到线程池。
            2.任务调度：线程池根据当前运行的线程数和配置参数决定如何处理新提交的任务（创建新线程、入队等待、拒绝等）。
            3.任务执行：工作线程从任务队列中获取任务并执行，完成后返回到线程池中等待新的任务。
            4.关闭线程池：通过调用shutdown()或shutdownNow()方法关闭线程池，停止接受新任务并处理现有任务。
        Java中的常见线程池类型包括：
            1.FixedThreadPool：固定大小的线程池，适合负载较稳定的场景。
            2.CachedThreadPool：可缓存的线程池，适合任务量波动较大的场景。
            3.SingleThreadExecutor：单线程化的线程池，适合需要顺序执行任务的场景。
            4.ScheduledThreadPool：支持定时和周期性任务执行的线程池，适合需要定时任务的场景。
        总结：Java中的线程池通过管理和复用线程，提高了多线程应用程序的性能和资源利用率。开发者可以根据具体需求选择合适的线程池类型，并通过合理配置参数来优化线程池的行为。
63.简述Java中的并发集合
        Java中的并发集合是专为多线程环境设计的数据结构，提供了线程安全的操作，避免了显式的同步代码，从而简化了并发编程。Java的并发集合主要位于java.util.concurrent包中，常见的并发集合包括：
            1.ConcurrentHashMap：一种高效的线程安全哈希表，允许多个线程同时读写。它通过分段锁（Segment Locking）机制实现高并发性能，适用于频繁读写操作的场景。
            2.CopyOnWriteArrayList：一种线程安全的动态数组实现，适用于读多写少的场景。每次写操作都会创建一个新的数组副本，从而保证读操作不会被阻塞。
            3.CopyOnWriteArraySet：基于CopyOnWriteArrayList实现的线程安全集合，适用于读多写少且不允许重复元素的场景。
            4.ConcurrentLinkedQueue：一种基于链表的无界线程安全队列，采用非阻塞算法实现高并发性能，适用于生产者-消费者模型。
            5.LinkedBlockingQueue：一种基于链表的有界阻塞队列，支持阻塞插入和移除操作，适用于生产者-消费者模型。
            6.PriorityBlockingQueue：一种基于优先级堆的无界阻塞队列，元素按优先级排序，适用于任务优先级调度。
            7.DelayQueue：一种基于优先级堆的无界阻塞队列，元素在指定延迟时间后才能被取出，适用于定时任务调度。
            8.SynchronousQueue：一种不存储元素的阻塞队列，每个插入操作必须等待对应的移除操作，适用于直接交互场景。
        并发集合通过内部机制（如锁、CAS操作等）确保在多线程环境下的数据一致性和完整性，同时提供了高效的并发性能。开发者可以根据具体需求选择合适的并发集合，以简化并发编程，提高代码的可读性和维护性。
64.简述Java中的锁机制
        Java中的锁机制是为了在多线程环境下确保共享资源的安全访问，防止数据竞争和不一致性。Java提供了多种锁机制，包括内置锁（synchronized关键字）和显式锁（如ReentrantLock），以及读写锁（ReadWriteLock）等。
            1.内置锁（Synchronized）：synchronized关键字用于修饰方法或代码块，确保同一时刻只有一个线程可以执行被修饰的代码。内置锁是可重入的，即同一线程可以多次获取同一把锁而不会导致死锁。内置锁的缺点是无法中断等待锁的线程，且性能相对较低。
            2.显式锁（ReentrantLock）：ReentrantLock类提供了比synchronized更灵活的锁机制。它支持公平锁和非公平锁，可以尝试获取锁（tryLock()方法），并且可以中断等待锁的线程。ReentrantLock还提供了Condition接口，用于实现更复杂的线程间通信。
            3.读写锁（ReadWriteLock）：ReadWriteLock接口定义了一种读写分离的锁机制，允许多个线程同时读取共享资源，但在写操作时只允许一个线程访问。ReentrantReadWriteLock是其常用实现，适用于读多写少的场景，提高了并发性能。
            4.StampedLock：StampedLock是一种支持乐观读、悲观读和写操作的锁机制，适用于高并发场景。它通过版本号来管理读写操作，提高了读操作的并发性，同时提供了更细粒度的控制。
        Java中的锁机制通过不同的实现方式和特性，满足了各种并发编程需求。开发者可以根据具体场景选择合适的锁机制，以确保数据的一致性和完整性，同时优化程序的性能。
65.简述Java中的线程通信
        Java中的线程通信是指多个线程之间通过共享资源或特定机制进行信息交换和协调，以实现协同工作。Java提供了多种线程通信方式，包括wait/notify机制、管道（PipedInputStream/PipedOutputStream）、BlockingQueue等。
            1.wait/notify机制：这是Java中最基本的线程通信方式，依赖于对象的监视器锁。线程可以调用wait()方法进入等待状态，释放锁并等待其他线程通过notify()或notifyAll()方法唤醒它。通常，wait/notify机制用于生产者-消费者模型中，实现线程间的协调。
            2.管道（PipedInputStream/PipedOutputStream）：管道是一种用于线程间通信的字节流，允许一个线程将数据写入管道，另一个线程从管道读取数据。管道适用于需要在两个线程之间传输大量数据的场景。
            3.BlockingQueue：BlockingQueue接口定义了一种支持阻塞操作的队列，允许多个线程安全地添加和移除元素。常见的实现类包括ArrayBlockingQueue、LinkedBlockingQueue等。BlockingQueue适用于生产者-消费者模型，简化了线程间的通信和同步。
            4.Exchanger：Exchanger类提供了一种用于两个线程之间交换数据的机制。两个线程可以通过Exchanger对象交换数据，当一个线程调用exchange()方法时，会等待另一个线程也调用该方法，从而实现数据交换。
            5.Semaphore：Semaphore类是一种计数信号量，用于控制对共享资源的访问。它允许多个线程同时访问一定数量的资源，通过acquire()和release()方法进行资源的获取和释放，从而实现线程间的协调。
        Java中的线程通信机制通过不同的方式满足了多线程环境下的信息交换和协同工作需求。开发者可以根据具体场景选择合适的通信方式，以提高程序的效率和响应性。
66.简述Java中的并发编程模型
        Java中的并发编程模型主要包括线程模型、任务模型和并发集合模型。这些模型帮助开发者有效地管理和协调多个线程的执行，提高程序的性能和响应性。
            1.线程模型：Java通过Thread类和Runnable接口提供了基本的线程创建和管理机制。开发者可以通过继承Thread类或实现Runnable接口来定义线程的行为。Java还提供了Executor框架，通过ExecutorService接口和ThreadPoolExecutor类实现线程池管理，简化了线程的创建、调度和销毁过程。
            2.任务模型：Java中的任务模型主要依赖于Callable接口和Future接口。Callable接口允许定义可以返回结果并抛出异常的任务，而Future接口用于表示异步计算的结果。通过ExecutorService的submit()方法，可以提交Callable任务并获得对应的Future对象，从而实现任务的异步执行和结果获取。
            3.并发集合模型：Java提供了一系列线程安全的集合类，如ConcurrentHashMap、CopyOnWriteArrayList、BlockingQueue等。这些并发集合通过内部机制（如锁、CAS操作等）确保在多线程环境下的数据一致性和完整性，简化了并发编程。
            4.锁机制：Java中的锁机制包括内置锁（synchronized关键字）、显式锁（ReentrantLock）、读写锁（ReadWriteLock）和StampedLock等。这些锁机制帮助开发者控制对共享资源的访问，防止数据竞争和不一致性。
            5.线程通信：Java提供了多种线程通信方式，如wait/notify机制、管道（PipedInputStream/PipedOutputStream）、BlockingQueue等。这些通信机制帮助多个线程之间进行信息交换和协调，实现协同工作。
        总结：Java中的并发编程模型通过线程模型、任务模型、并发集合模型、锁机制和线程通信等多方面的协同工作，实现了多线程程序的高效运行和资源管理。开发者需要理解这些模型，以编写高性能、安全的并发应用程序。
67.简述Java中的Fork/Join框架
        Java中的Fork/Join框架是Java 7引入的一种并行计算框架，旨在简化多核处理器上的任务分解和并行执行。它基于分治算法，将大任务拆分为多个小任务，并利用工作窃取（work-stealing）算法实现高效的线程调度和负载均衡。
            1.核心组件：Fork/Join框架的核心组件包括ForkJoinPool和ForkJoinTask。ForkJoinPool是一个特殊的线程池，负责管理和调度ForkJoinTask任务。ForkJoinTask是一个抽象类，定义了任务的基本行为，常用的子类包括RecursiveAction（无返回值任务）和RecursiveTask（有返回值任务）。
            2.任务分解：在Fork/Join框架中，任务通常通过递归方式进行分解。开发者需要重写compute()方法，在该方法中判断任务是否足够小，如果是则直接执行，否则将任务拆分为更小的子任务，并调用fork()方法将子任务提交到ForkJoinPool中执行。
            3.任务合并：当子任务完成后，可以通过join()方法获取子任务的结果，并将结果合并到父任务中。对于RecursiveTask，可以在compute()方法中返回合并后的结果。
            4.工作窃取：Fork/Join框架采用工作窃取算法，当一个工作线程完成了自己的任务后，会尝试从其他忙碌的线程中“窃取”未完成的任务，从而提高资源利用率和并行性能。
            5.使用场景：Fork/Join框架适用于计算密集型任务，如大规模数据处理、图像处理、科学计算等。它能够充分利用多核处理器的计算能力，提高程序的执行效率。
        总结：Java中的Fork/Join框架通过任务分解、并行执行和工作窃取等机制，实现了高效的多线程计算。开发者可以利用该框架简化并行编程，提高程序在多核环境下的性能表现。
68.简述Java中的CompletableFuture
        Java中的CompletableFuture是Java 8引入的一种异步编程工具，位于java.util.concurrent包中。它扩展了Future接口，提供了更丰富的功能和更灵活的方式来处理异步计算任务。CompletableFuture支持链式调用、组合多个异步任务以及处理异常等功能，使得异步编程更加简洁和易读。
            1.创建CompletableFuture：可以通过静态方法supplyAsync()或runAsync()创建一个CompletableFuture对象，前者用于有返回值的任务，后者用于无返回值的任务。也可以通过completedFuture()方法创建一个已经完成的CompletableFuture。
            2.链式调用：CompletableFuture支持链式调用，可以通过thenApply()、thenAccept()、thenRun()等方法对异步任务的结果进行处理。这些方法会在前一个任务完成后自动执行，形成一个任务链。
            3.组合多个任务：可以使用allOf()和anyOf()方法将多个CompletableFuture组合在一起。allOf()等待所有任务完成，而anyOf()只等待其中一个任务完成，从而实现复杂的异步工作流。
            4.异常处理：CompletableFuture提供了exceptionally()和handle()方法，用于处理异步任务中的异常情况。这样可以确保即使某个任务失败，整个异步流程仍然能够继续执行。
            5.阻塞等待结果：虽然CompletableFuture主要用于异步编程，但也可以通过get()或join()方法阻塞等待任务完成并获取结果。不过，这种方式会阻塞当前线程，通常不推荐在异步场景中使用。
        总结：Java中的CompletableFuture通过丰富的API和灵活的组合方式，简化了异步编程，提高了代码的可读性和维护性。开发者可以利用CompletableFuture实现高效的异步计算和复杂的并发工作流。
69.简述Java中的原子变量
        Java中的原子变量是指在多线程环境下能够保证操作的原子性（不可分割性）的变量。Java通过java.util.concurrent.atomic包提供了一系列原子变量类，这些类利用底层的硬件支持（如CAS操作）实现了高效的线程安全操作，避免了显式的锁机制，从而提高了并发性能。
            1.常见的原子变量类：Java提供了多种原子变量类，包括AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference等。这些类分别用于处理整数、长整数、布尔值和引用类型的原子操作。
            2.基本操作：原子变量类提供了一系列方法，如get()、set()、getAndIncrement()、compareAndSet()等，用于获取和修改变量的值。这些方法都是线程安全的，确保在多线程环境下对变量的操作不会导致数据不一致。
            3.CAS操作：原子变量类内部使用了比较并交换（Compare-And-Swap，CAS）算法来实现无锁的线程安全操作。CAS通过比较内存中的值与预期值，如果相等则更新为新值，否则重试，确保了操作的原子性。
            4.应用场景：原子变量适用于需要频繁更新共享变量且对性能要求较高的场景，如计数器、标志位等。相比于使用synchronized关键字或ReentrantLock，原子变量能够提供更高的并发性能和更低的延迟。
            5.限制：虽然原子变量提供了高效的线程安全操作，但它们只能保证单个变量的原子性。如果需要对多个变量进行原子操作，仍然需要使用锁机制或其他同步手段来确保数据的一致性。
        总结：Java中的原子变量通过CAS操作实现了高效的线程安全操作，适用于多线程环境下对共享变量的频繁更新。开发者可以根据具体需求选择合适的原子变量类，以提高程序的并发性能和响应速度。
70.简述Java中的并发设计模式
        Java中的并发设计模式是为了解决多线程编程中常见问题而提出的一些设计方案。这些模式帮助开发者更好地管理线程、协调任务和共享资源，提高程序的并发性能和可维护性。常见的并发设计模式包括：
            1.生产者-消费者模式（Producer-Consumer Pattern）：该模式通过使用阻塞队列（如BlockingQueue）实现生产者线程和消费者线程之间的协调。生产者负责生成数据并放入队列，消费者从队列中取出数据进行处理，从而实现异步处理和负载均衡。
            2.读写锁模式（Read-Write Lock Pattern）：该模式利用读写锁（如ReentrantReadWriteLock）实现对共享资源的读写分离。多个线程可以同时读取资源，但在写操作时只允许一个线程访问，从而提高了读操作的并发性。
            3.线程池模式（Thread Pool Pattern）：该模式通过使用线程池（如ExecutorService）管理和复用线程，避免了频繁创建和销毁线程的开销。线程池可以根据任务量动态调整线程数量，提高资源利用率和响应速度。
            4.未来模式（Future Pattern）：该模式通过使用Future接口和CompletableFuture类实现异步任务的执行和结果获取。任务提交后，调用方可以继续执行其他操作，稍后再获取任务结果，从而提高程序的并发性。
            5.双重检查锁定模式（Double-Checked Locking Pattern）：该模式用于实现单例模式中的延迟初始化，确保在多线程环境下只有一个实例被创建。通过在获取实例时进行两次检查，减少了锁的使用，提高了性能。
            6.工作窃取模式（Work-Stealing Pattern）：该模式通过Fork/Join框架实现任务的动态分配和调度。当一个工作线程完成了自己的任务后，会尝试从其他忙碌的线程中“窃取”未完成的任务，从而提高资源利用率和并行性能。
        总结：Java中的并发设计模式提供了一系列解决多线程编程问题的有效方案，帮助开发者更好地管理线程、协调任务和共享资源。通过合理应用这些设计模式，可以提高程序的并



        
        
        


        
            
        
    
    
                
            
    
            
            
            
            
    

    




    
        
        
        
        

    
    
        



    

