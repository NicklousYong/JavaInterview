// 数据结构题目
1.HashMap是线程安全的吗？多线程场景下会有什么问题？
    不是线程安全的。
    多线程场景下会出现以下问题：
        1.扩容死循环：在JDK1.7中，HashMap采用头插法插入元素，当多个线程进行扩容操作时，可能会导致环形链表的形成，从而进入死循环。在1.8中，jdk采用尾插法进行这个操作，保证了链表的顺序，从而避免了死循环的问题。
            HashMap1.7的扩容采用头插法，假设有A,B两个线程对一个Map进行操作，分别创建一个新的数组对象，
        然后将原数组中的元素重新hash到新的数组中，假设A线程先执行完毕，，此时A线程将当前节点标记为M，下一个节点标记为N,B线程后执行完毕，那么B线程在插入元素时，
        会将M节点的下一个节点标记为N。 这样就形成了一个环形链表，导致死循环。JDK1.8中使用尾插法解决了这个问题
        2.数据丢失：多个线程同时对HashMap进行put操作时，如果多个对象计算出相同的索引位置，那么后面一个会覆盖前面一个，造成元素丢失。
        3.get为null:如果一个线程在扩容，而另一个线程在get,就会发生get不到的情况。这是因为扩容的过程中，hashMap的结构发生了变化，导致get操作获取不到元素。

2.多线程场景下,HashMap的解决方案：
        1.使用ConcurrentHashMap:
                1.使用分段锁或CAS+synchronized来实现粒度同步，允许多个线程同时读写。
                2.内部实现了线程安全的扩容机制，避免了HashMap环形链表的问题。
                3.支持原子操作无需加锁。
        2.使用Collections.synchronizedMap()
            1.将HashMap包装成线程安全的Map。
            2.通过synchronized关键字实现同步，保证线程安全。
            3.适用于读多写少的场景。
        3.手动加锁synchronized或ReentrantLock
        4.避免多线程共享HashMap




            
        