// 数据结构题目
1.HashMap是线程安全的吗？多线程场景下会有什么问题？
    不是线程安全的。
    多线程场景下会出现以下问题：
        1.扩容死循环：在JDK1.7中，HashMap采用头插法插入元素，当多个线程进行扩容操作时，可能会导致环形链表的形成，从而进入死循环。在1.8中，jdk采用尾插法进行这个操作，保证了链表的顺序，从而避免了死循环的问题。
            HashMap1.7的扩容采用头插法，假设有A,B两个线程对一个Map进行操作，分别创建一个新的数组对象，
        然后将原数组中的元素重新hash到新的数组中，假设A线程先执行完毕，，此时A线程将当前节点标记为M，下一个节点标记为N,B线程后执行完毕，那么B线程在插入元素时，
        会将M节点的下一个节点标记为N。 这样就形成了一个环形链表，导致死循环。JDK1.8中使用尾插法解决了这个问题
        2.数据丢失：多个线程同时对HashMap进行put操作时，如果多个对象计算出相同的索引位置，那么后面一个会覆盖前面一个，造成元素丢失。
        3.get为null:如果一个线程在扩容，而另一个线程在get,就会发生get不到的情况。这是因为扩容的过程中，hashMap的结构发生了变化，导致get操作获取不到元素。

2.多线程场景下,HashMap的解决方案：
        1.使用ConcurrentHashMap:
                1.使用分段锁或CAS+synchronized来实现粒度同步，允许多个线程同时读写。
                2.内部实现了线程安全的扩容机制，避免了HashMap环形链表的问题。
                3.支持原子操作无需加锁。
        2.使用Collections.synchronizedMap()
            1.将HashMap包装成线程安全的Map。
            2.通过synchronized关键字实现同步，保证线程安全。
            3.适用于读多写少的场景。
        3.手动加锁synchronized或ReentrantLock
        4.避免多线程共享HashMap
3.Java集合类框架的基本接口有哪些？
    1.Collection接口：是所有集合类的根接口，定义了基本的集合操作方法，如add、remove、clear、size等。
    2.List接口：继承自Collection接口，表示有序的元素集合，允许重复元素。常见实现类有ArrayList、LinkedList等。
    3.Set接口：继承自Collection接口，表示不允许重复元素的集合。常见实现类有HashSet、TreeSet等。
    4.Map接口：表示键值对映射关系的集合，不继承自Collection接口。常见实现类有HashMap、TreeMap等。
    5.Queue接口：继承自Collection接口，表示先进先出的队列。常见实现类有LinkedList、PriorityQueue等。
    6.Deque接口：继承自Queue接口，表示双端队列，允许在两端插入和删除元素。常见实现类有ArrayDeque等。
4.ArrayList和LinkedList的区别？
    1.底层数据结构不同：
        ArrayList底层是基于动态数组实现的，支持随机访问，查询效率高，但插入和删除操作较慢，因为需要移动元素。
        LinkedList底层是基于双向链表实现的，插入和删除操作较快，不需要移动元素，但查询效率较低，因为需要遍历链表。
    2.内存占用不同：
        ArrayList由于使用数组存储元素，内存占用较小，但在扩容时需要创建新的数组并复制元素，可能会浪费空间。
            ArrayList扩容操作：
                默认是10个长度，当长度达到数组容量，会进行扩容操作，每次扩容1.5倍。
        LinkedList由于每个节点都包含前后指针，内存占用较大，但不需要扩容操作。
    3.适用场景不同：
        ArrayList适用于读多写少的场景，如频繁查询元素的情况。
        LinkedList适用于写多读少的场景，如频繁插入和删除元素的情况。
5.HashMap和Hashtable的区别？
    1.线程安全性：
        HashMap是非线程安全的，适用于单线程环境或通过外部同步机制保证线程安全。
        Hashtable是线程安全的，内部使用synchronized关键字实现同步，但性能较低。
    2.允许null键和值：
        HashMap允许一个null键和多个null值。
        Hashtable不允许null键和null值。
            为什么HashTable不允许null键和null值？ 
                1.历史原因：Hashtable是Java早期版本中的类，当时设计时没有考虑null键和值的情况。
                2.HashTable是线程安全的，这就要求使用synchronized关键字来保证线程安全，而在同步方法中处理null键和值会增加复杂性和潜在的错误风险。
    3.性能：
        HashMap在大多数情况下性能优于Hashtable，尤其是在多线程环境下，因为Hashtable的同步机制会导致性能瓶颈。
    4.迭代器：
        HashMap使用fail-fast迭代器，在迭代过程中如果结构发生变化会抛出ConcurrentModificationException异常。
        Hashtable使用Enumerator迭代器，不是fail-fast的，允许在迭代过程中修改结构，但可能导致不一致的结果。
    5.继承关系：
        HashMap继承自AbstractMap类，实现了Map接口。
        Hashtable继承自Dictionary类，实现了Map接口，但Dictionary是一个过时的类，不推荐使用。
6.HashMap的底层实现原理？
    HashMap底层是基于数组和链表（在JDK1.8及以上版本中还引入了红黑树）实现的。
    1.数据存储结构：
        HashMap使用一个数组来存储键值对，每个数组元素称为桶（bucket）。每个桶可以存储多个键值对，这些键值对通过链表或红黑树连接在一起。
    2.哈希函数：
        HashMap通过哈希函数将键映射到数组的索引位置。哈希函数计算键的哈希码，然后通过取模运算确定该键应该存储在哪个桶中。
    3.处理哈希冲突：
        当多个键映射到同一个桶时，HashMap会使用链表或红黑树来存储这些键值对。
        在JDK1.7及以下版本中，使用链表来处理冲突；在JDK1.8及以上版本中，当链表长度超过一定阈值（默认是8）时，会将链表转换为红黑树，以提高查询效率。
    4.扩容机制：
        当HashMap中的元素数量超过负载因子（默认是0.75）与当前容量的乘积时，HashMap会进行扩容操作。
        扩容时，会创建一个新的更大的数组，并将原数组中的元素重新哈希并插入到新数组中。
    5.时间复杂度：
        在理想情况下，HashMap的插入、删除和查询操作的时间复杂度为O(1)。
        但在最坏情况下（如所有键都映射到同一个桶），时间复杂度可能退化为O(n)。通过使用红黑树，可以将最坏情况的时间复杂度降低到O(log n)。
7.HashMap的扩容机制？
    1.触发条件：
        HashMap在插入新元素时，如果当前元素数量超过了负载因子（默认是0.75）与当前容量的乘积，就会触发扩容操作。
    2.扩容过程：
        扩容时，HashMap会创建一个新的数组，容量通常是当前容量的两倍。
        然后，将原数组中的所有元素重新哈希并插入到新数组中。这个过程称为再哈希（rehashing）。
    3.再哈希：
        在再哈希过程中，HashMap会遍历原数组中的每个桶，对于每个桶中的链表或红黑树节点，重新计算它们在新数组中的索引位置，并将它们插入到新数组的相应位置。
        由于数组容量变大，元素在新数组中的分布可能会发生变化，从而减少哈希冲突的概率。
    4.性能影响：
        扩容操作是一个耗时的过程，因为需要创建新的数组并重新插入所有元素。因此，在设计HashMap时，应尽量避免频繁的扩容操作，可以通过设置合适的初始容量和负载因子来优化性能。
    5.线程安全：
        在多线程环境下，扩容操作可能导致数据不一致的问题，因此在使用HashMap时应注意线程安全问题，或者考虑使用ConcurrentHashMap等线程安全的替代方案。

8.什么是负载因子？默认值是多少？如何影响HashMap的性能？
    1.定义：
        负载因子（Load Factor）是HashMap中一个重要的参数，用于衡量HashMap的填充程度。它表示当前元素数量与数组容量的比值。
        负载因子 = 元素数量 / 数组容量
    2.默认值：
        HashMap的默认负载因子是0.75。这意味着当HashMap中的元素数量达到数组容量的75%时，就会触发扩容操作。
    3.性能影响：
        负载因子对HashMap的性能有直接影响：
            - 较低的负载因子（如0.5）会减少哈希冲突的概率，从而提高查询效率，但会增加内存消耗，因为数组容量会更大。
            - 较高的负载因子（如0.9）会节省内存，但可能增加哈希冲突的概率，导致查询效率下降。
        因此，选择合适的负载因子需要在内存使用和性能之间进行权衡。默认值0.75被认为是一个较好的折中选择，既能提供较好的性能，又不会浪费过多内存。
    4.调整负载因子：
        在创建HashMap时，可以通过构造函数指定自定义的负载因子，以满足特定应用场景的需求。
        例如，如果预期HashMap中会存储大量元素，可以选择较低的负载因子以提高性能。
9.什么是HashSet ？它是如何实现的？
    1.定义：
        HashSet是Java集合框架中的一个类，用于存储不重复的元素。它实现了Set接口，底层是基于HashMap实现的。
    2.底层实现：
        HashSet内部使用一个HashMap来存储元素。每个元素作为HashMap的键（key），而值（value）则是一个固定的常量对象（通常是一个静态的Object实例）。
        由于HashMap不允许重复的键，因此HashSet也不允许重复的元素。
    3.主要方法：
        - add(E e)：将指定元素添加到HashSet中，如果元素已经存在则不添加，返回false；否则返回true。
        - remove(Object o)：从HashSet中移除指定元素，如果元素存在则移除并返回true；否则返回false。
        - contains(Object o)：检查HashSet中是否包含指定元素，返回true或false。
        - size()：返回HashSet中元素的数量。
        - clear()：清空HashSet中的所有元素。
    4.性能：
        HashSet的插入、删除和查询操作的时间复杂度为O(1)，在理想情况下表现良好。但在最坏情况下（如所有元素都映射到同一个桶），时间复杂度可能退化为O(n)。
        通过使用良好的哈希函数和适当的负载因子，可以减少哈希冲突，提高性能。
    5.线程安全：
        HashSet本身不是线程安全的。如果在多线程环境下使用，需要通过外部同步机制（如Collections.synchronizedSet()）来保证线程安全，或者考虑使用ConcurrentSkipListSet等线程安全的替代方案。
10.ConcurrentHashMap原理？
    1.定义：
        ConcurrentHashMap是Java集合框架中的一个类，用于在多线程环境下存储键值对。它实现了Map接口，提供了高效的并发访问能力。
    2.底层实现：
        ConcurrentHashMap的底层实现与HashMap类似，使用数组和链表（在JDK1.8及以上版本中还引入了红黑树）来存储键值对。
        但与HashMap不同的是，ConcurrentHashMap采用了分段锁（Segment Locking）和无锁（Lock-Free）技术来实现高效的并发访问。
    3.分段锁：
        在JDK1.7及以下版本中，ConcurrentHashMap将整个Map划分为多个段（Segment），每个段内部使用独立的锁进行同步。
        这样，不同段之间的操作可以并发进行，提高了并发性能。
        在JDK1.8及以上版本中，ConcurrentHashMap取消了Segment的概念，改为使用CAS（Compare-And-Swap）操作和synchronized关键字来实现更细粒度的锁定。
    4.CAS操作：
        CAS是一种无锁的并发编程技术，通过比较和交换操作来实现原子性更新。ConcurrentHashMap使用CAS操作来更新桶中的节点，从而减少锁的竞争，提高并发性能。
    5.主要方法：
        - put(K key, V value)：将指定键值对添加到ConcurrentHashMap中，如果键已经存在则更新其值。
        - get(Object key)：根据指定键获取对应的值，如果键不存在则返回null。
        - remove(Object key)：从ConcurrentHashMap中移除指定键及其对应的值。
        - size()：返回ConcurrentHashMap中键值对的数量。
        - clear()：清空ConcurrentHashMap中的所有键值对。
    6.性能：
        ConcurrentHashMap在多线程环境下表现出色，能够支持高并发读写操作。通过分段锁和CAS操作，减少了锁的粒度和竞争，提高了整体性能。
    7.线程安全：
        ConcurrentHashMap是线程安全的，可以在多线程环境下安全地进行读写操作，而无需外部同步机制。这使得它成为多线程应用中常用的集合类之一。
11.什么是红黑树？它有哪些性质？
    1.定义：
        红黑树是一种自平衡的二叉搜索树（Binary Search Tree），它通过对节点进行颜色标记（红色或黑色）来保持树的平衡，
        从而确保基本操作（如插入、删除和查找）的时间复杂度为O(log n)。
    2.性质：
        红黑树具有以下五个重要性质：
            1.每个节点要么是红色，要么是黑色。
            2.根节点必须是黑色。
            3.所有叶子节点（NIL节点）都是黑色。
            4.如果一个节点是红色的，则其子节点必须是黑色的（即不能有两个连续的红色节点）。
            5.从任一节点到其所有后代叶子节点的路径上，必须包含相同数量的黑色节点（即黑高相同）。
    3.操作：
        - 插入：在插入新节点时，首先按照二叉搜索树的规则插入，然后通过重新着色和旋转操作来恢复红黑树的性质。
        - 删除：在删除节点时，首先按照二叉搜索树的规则删除，然后通过重新着色和旋转操作来恢复红黑树的性质。
        - 查找：查找操作与普通二叉搜索树类似，通过比较键值沿着树进行遍历，直到找到目标节点或到达叶子节点。
    4.应用：
        红黑树广泛应用于各种数据结构和算法中，如Java中的TreeMap和TreeSet、
        C++中的std::map和std::set等。它们利用红黑树的自平衡特性来实现高效的有序数据存储和检索。
    5.优点：
        - 保持平衡：红黑树通过颜色标记和旋转操作保持树的平衡，确保基本操作的时间复杂度为O(log n)。
        - 高效：相比其他自平衡二叉搜索树（如AVL树），红黑树在插入和删除操作上更高效，因为它允许一定程度的不平衡，从而减少了旋转操作的次数。
        - 灵活性：红黑树适用于各种动态数据集，能够高效地处理频繁的插入和删除操作。
12.什么是B+树？
    1.定义：
        B+树是一种多路平衡搜索树（Balanced Search Tree），广泛应用于数据库和文件系统中。它是B树的一种变体，具有更高的查询效率和更好的范围查询性能。
    2.结构：
        B+树由内部节点和叶子节点组成。内部节点只存储键值，用于导航树的结构，而叶子节点存储实际的数据记录。
        所有叶子节点通过指针连接，形成一个有序的链表，便于范围查询。
    3.性质：
        B+树具有以下重要性质：
            1.所有叶子节点都在同一层，确保了树的平衡。
            2.每个内部节点（非叶子节点）至少有⌈m/2⌉个子节点，最多有m个子节点，其中m是B+树的阶数。
            3.每个叶子节点至少包含⌈(m-1)/2⌉个键值，最多包含m-1个键值。
            4.所有键值都存储在叶子节点中，内部节点只存储导航信息。
            5.叶子节点通过指针连接，形成一个有序的链表，便于范围查询。
    4.操作：
        - 插入：在插入新键值时，首先找到合适的叶子节点进行插入。如果叶子节点已满，则需要进行分裂操作，将中间键提升到父节点，并可能递归地分裂父节点。
        - 删除：在删除键值时，首先找到对应的叶子节点进行删除。如果删除后叶子节点的键值数量低于最小要求，则需要进行合并或借用操作，以保持B+树的性质。
        - 查找：查找操作从根节点开始，通过比较键值沿着内部节点导航，直到找到目标叶子节点，然后在叶子节点中查找实际数据记录。
    5.应用：
        B+树广泛应用于数据库索引和文件系统中，如MySQL、PostgreSQL等数据库管理系统都使用B+树作为默认的索引结构。它们利用B+树的高效查询和范围查询能力来优化数据访问性能。







            
        