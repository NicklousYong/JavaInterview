//垃圾回收机制题目
1.Serial与Parallel GC之间的区别是什么？
   两者都会stop-the-world,但是parallel GC在进行垃圾回收时会使用多个线程来并行处理垃圾回收任务，从而提高了垃圾回收的效率，适用于多核处理器环境。而Serial GC则是单线程进行垃圾回收，适用于单核处理器或内存较小的环境。
2.JVM选项中-XX:UseCompressedOops的作用是什么？
   该选项用于启用或禁用压缩对象指针（Compressed Oops）。启用后，JVM会使用32位的指针来引用对象，从而减少内存占用，提高性能。适用于堆内存小于32GB的环境。
3.JVM内存区域
            线程共享的有：
                方法区：存储类信息，常量，静态变量，即时编译后的的代码缓存等，也包括运行时常量池。
                堆：线程共享的一个内存区域，大部分对象是在堆上分配，少部分对象在栈上分配。 堆中有新生代和老年代之分，目的是为了垃圾回收更搞笑和更少的停顿。 新生代： 伊甸区，s0，s1 老年代
			线程私有的有：
                虚拟机栈：存储线程的局部变量表，操作数栈，动态链接和方法出口等参数。
                        局部变量表：基本数据类型，引用数据类型，返回地址
                        操作数栈：方法调用的记录。
                        动态链接：将运行时常量池的符号引用转为连接引用。
                        方法返回：用于存放该方法的PC寄存器的值。存放下一个执行指令。
                本地方法栈：和虚拟机栈类似，但是是为了native方法服务的。
                程序计数器：用来指示程序走到了哪里；线程私有，每个线程自己维护，互不影响。
            直接内存:受系统管理，不归JVM管理
4.JVM垃圾收集算法：
        1.垃圾标记算法：   
            1.可达性分析法：
                通过跟集合作为起始点，从这些节点出发，根据引用关系开始搜索，如果对象没有被任何引用链访问，说明该对象不活跃，可以被回收。
                根节点：虚拟机栈中引用的对象，方法区中静态类属性引用的对象；方法区中常量引用的对象；本地方法栈中引用的对象。
                可达分析法的垃圾回收效率较高，实现起来比较简单，但是会STW。
            2.引用计数法：堆中会维护一个空间。
                    如果有新的引用指向这个对象，则引用的数值加一；
                    如果指向该对象的引用被置空或者指向其他对象，则计数器减一。
                    当计数器的值为0时，则会自动删除这个对象。
            3.三色标记法：
				白色：还未被垃圾回收期标记的对象。
				灰色：自身已经被标记，但拥有的成员变量还为被标记。
				黑色：自身已经被标记，但对象本身所有的成员变量也已经被标记。
        2.垃圾清除算法：					
                标记-清除法： 由标记阶段和清除阶段构成。标记阶段会对需要清除的垃圾进行标记，清除阶段会对对垃圾进行清除。
                            缺点：会stw，并且有内存碎片存在。
                标记-整理法：标记后将存活对象向一端移动，再清空剩余区域，无碎片但需移动对象。
                标记-复制法：把内存分为两块，当from区域填满时，触发GC:
                            扫描from区，将存活对象复制到to区，并重新计算内存地址。
                            复制完成后，直接清空From区。
                            优点：
                                1.不会发生碎片化
                                2.优秀的吞吐率
                                3.实现高速分配
                            缺点：堆空间的利用率很低
        4.分代收集算法：
                把对分为新生代，老年代。如果新生代的对象一直没有被回收，就会被放到老年代。
                新生代通常占堆的1/3；主要使用复制算法。
        5.并发算法：
                1.并发标记：从GCRoots触发，使用遍历算法堆对象的成员变量进行标记。
                2.并发转移：将并发标记的对象转移到新的位置，从而获得空余内存。
                3.并发重定位：因为并发转移的存在，需要在转移之后重新定位指针的位置。
5.垃圾回收器：
    按照侧重点划分：
        1.吞吐量优先型回收器（适合后台任务、批处理）
                目标：最大化单位时间内的代码执行效率（吞吐量 = 运行用户代码时间 / 总时间），允许偶尔较长的 GC 停顿。
                Parallel Scavenge（新生代回收器）：使用标记-复制算法
                    将新生代划分为1个Eden和2个Survivor区(比例为8：1：1)，新生对象会优先分配到Eden区，当Eden区满时，触发Minor GC，将存活对象复制到Survivor区。
                    默认进入老年区的年龄为15。
                    特点：采用"并行回收",减少GC时间。
                Parallel Old（老年代回收器）：使用标记-整理算法
                    标记：遍历所有老年代对象，标记存活对象。
                    整理：将所有存活对象向内存一端移动，避免内存指针碎片。
                    清除：清除未被标记的对象，释放内存。
                特点：专注吞吐量优化。
        2.低延迟响应型回收器(适合响应式应用、Web服务)
                目标：最小化GC停顿时间(减少对用户体验的影响)，允许适当牺牲吞吐量。
                1.CMS(Concurrent Mark-Sweep，老年代回收器）：使用标记-清除算法
                    初始标记：STW，标记与GC Roots直接关联的对象。
                    并发标记：与应用线程并发，遍历对象图，标记所有可达对象。
                    重新标记：STW，修正并发标记期间发生变化的对象引用。
                    并发清除：与应用线程并发，清除未被标记的对象。
                    特点：减少停顿时间，但可能导致内存碎片。
                    优点：大部分工作与用户线程并发，GC停顿时间短。
                    缺点：可能导致内存碎片，无法回收大对象。
                2.G1跨代回收器（Garbage-First Collector）：使用标记-整理算法
                        核心算法：分代回收 + 区域化标记 - 复制 + 标记 - 整理
                        原理（突破传统 “连续内存代” 设计，将堆划分为多个大小相等的独立 Region）：
                        区域化划分：堆被分为 Eden Region、Survivor Region、Old Region，每个 Region 可动态切换角色（如 Old Region 可转为 Eden Region）；
                        优先回收价值最高的 Region：通过 “记忆集”（Remembered Set）记录 Region 间的引用关系，GC 时优先回收垃圾比例高、回收收益大的 Region（“Garbage-First” 得名）；
                        混合回收（Mixed GC）：同时回收新生代和部分老年代 Region，采用 “标记 - 复制” 算法（将存活对象复制到空 Region，清除原 Region），避免碎片；
                        停顿预测模型：通过 XX:MaxGCPauseMillis（默认 200ms）设定目标停顿时间，动态调整回收 Region 数量，确保停顿可控。
                    特点：兼顾吞吐量和延迟，适合大内存应用。
                3.ZGC(Z Garbage Collector ,低延迟回收器)
                    适用代：全堆（不分新生代 / 老年代，JDK 11 引入，专为超大堆设计）。
                    核心算法：区域化标记 - 复制 + 颜色指针（Colored Pointers） + 读屏障（Load Barrier）
                    原理（突破传统 GC 对 “停顿” 的依赖，核心是 “并发处理所有阶段”）：
                    颜色指针：将对象指针的几位用于标记对象状态（如 “白色” 未标记、“灰色” 待标记、“黑色” 已标记），避免传统 GC 的 “标记阶段停顿”；
                    读屏障：在用户线程读取对象引用时插入屏障，动态处理并发回收中的对象引用变动（无需停顿用户线程）；
                    并发回收全阶段：标记、复制、清理均与用户线程并发，仅在初始标记和最终清理时有极短停顿（通常 < 10ms，且与堆大小无关）。
                    特点：
                        支持 TB 级超大堆（如 16TB），停顿时间稳定在毫秒级；
                        完全并发回收，几乎不影响服务响应时间，适合金融、电商等对延迟敏感的核心系统。
总结：
    回收器	            适用场景	        核心算法组合	                            关键优势
    Parallel 组合	    吞吐量优先	    新生代：标记 - 复制；老年代：标记 - 整理	    高吞吐量，适合批处理
    CMS	                低延迟（JDK 8）	老年代：标记 - 清除；新生代：标记 - 复制	    并发回收，停顿短
    G1	                平衡型（默认）	    区域化标记 - 复制 + 分代回收	            兼顾吞吐量与延迟，支持大堆
    ZGC	                超低延迟（超大堆）	颜色指针 + 并发标记 - 复制	                毫秒级停顿，支持 TB 级堆
按照分代年龄区分：
    新生代收集器有：
    收集器名称	        核心算法	    线程模型	    核心特性	                                                                适用场景
    Serial	            复制算法	    单线程	    实现最简单，无线程切换开销  
                                                回收时会 “Stop The World”（STW，暂停所有用户线程），停顿时间较长	            单核 CPU 环境、内存较小的场景（对延迟不敏感）
                                                客户端应用（如桌面程序）  - 
    ParNew	            复制算法	    多线程（并行） Serial 的 “多线程版本”，核心逻辑与 Serial 一致                               服务端应用（如 Web 服务）   
                                                支持通过-XX:ParallelGCThreads配置回收线程数                                 多核 CPU 环境  
                                                仍会 STW，但停顿时间比 Serial 短（多核 CPU 下）	                            唯一能与老年代收集器CMS配合使用的新生代收集器
    Parallel Scavenge	复制算法	多线程（并行）	    以 “吞吐量优先” 为核心目标（吞吐量 = 用户代码运行时间 /(用户代码时间 + GC 时间)） 
                                                支持 “自适应调节策略”（-XX:+UseAdaptiveSizePolicy）                         对吞吐量要求高、对延迟不敏感的场景（如后台计算、大数据处理）
                                                JVM 自动调整新生代大小、Survivor 区比例等参数，无需手动优化                      希望减少手动 GC 参数调优的场景
                                                STW 停顿时间比 ParNew 略短（专注吞吐量优化）	                                
    老年代收集器有：
    收集器名称	    核心算法	        线程模型	    核心特性	                                           适用场景
    Serial Old	    标记 - 整理算法	单线程	    Serial 的老年代版本，逻辑简单                          客户端应用（搭配 Serial 新生代收集器）
                                                回收时 STW，停顿时间长（老年代对象多，回收耗时久）          作为 “应急回收器”：当其他老年代收集器（如 CMS）出现故障时，JVM 会自动切换为 Serial Old
    Parallel Old	标记 - 整理算法	多线程（并行）	Parallel Scavenge 的老年代版本，以 “吞吐量优先” 为目标 
                                                支持多线程并行回收，STW 停顿时间比 Serial Old 短         对吞吐量要求高、允许一定 STW 停顿的服务端场景（如大数据离线计算、批量处理任务） 
                                                与 Parallel Scavenge 组成 “Parallel Scavenge 
                                                + Parallel Old” 组合，是 JDK 8 默认的收集器组合	 
    CMS  	        标记 - 清除算法	多线程（并发）	以 “低延迟” 为核心目标，首次实现 “GC 线程与用户线程并发执行” 
                                                回收流程分 4 步：初始标记（STW）→并发标记（无 STW）
                                                →重新标记（STW）→并发清除（无 STW），仅两个短 STW 阶段
                                                - 缺点：
                                                1. 并发阶段占用 CPU 资源，可能导致用户线程吞吐量下降；
                                                2. 标记 - 清除算法产生内存碎片，
                                                可能触发 “Full GC”（使用 Serial Old 整理碎片）；
                                                3. 无法处理 “浮动垃圾”（并发清除阶段产生的新垃圾，需下次 GC 回收）
    分代收集器组合（生产环境常用搭配）：
        Serial + Serial Old：单线程全分代回收，仅适用于客户端或简单场景。
        ParNew + CMS：低延迟组合，新生代并行回收、老年代并发回收，是 JDK 7/8 中延迟敏感场景的首选。
        Parallel Scavenge + Parallel Old：吞吐量优先组合，全分代并行回收，JDK 8 默认组合，适用于吞吐量优先场景。
    不分代垃圾收集器（打破 “新生代 + 老年代” 模型）：
        收集器名称	    核心算法	                     线程模型	            核心特性	                                                                                                                    适用场景
        G1              整体标记 - 整理，局部复制算法	多线程（并行 + 并发）	    核心思想：将堆内存划分为多个大小相等的 “Region”（区域），每个 Region 可动态标记为新生代、老年代或大对象区
                                                                            以 “延迟优先” 为目标，支持通过-XX:MaxGCPauseMillis设置最大停顿时间，JVM 自动选择回收价值最高的 Region（“Garbage-First”）                 大内存场景（堆内存≥4GB）
                                                                            回收流程：初始标记（STW）→并发标记（无 STW）→最终标记（STW）→筛选回收（STW，并行执行）                                                   对延迟和吞吐量均有要求的服务端应用（如电商交易、分布式服务） 
                                                                            优点：兼顾延迟与吞吐量，无内存碎片（筛选回收时采用复制算法）；
                                                                            缺点：内存 Region 划分带来一定开销，小内存场景下性能不如传统分代收集器	- JDK 9 及以上默认收集器
        ZGC         	标记 - 复制算法	            多线程（并发）	            设计目标：低延迟（亚毫秒级 STW）、大内存（支持 TB 级堆内存）、高吞吐量
                                                                            核心技术：                                                                                                                    JDK 11 及以上（实验性→正式版）
                                                                            1. “着色指针”：通过指针标记对象状态（如是否存活），避免传统的 “对象头标记” 开销；                                                         超大内存场景（如 TB 级堆内存，如数据库、大数据平台）
                                                                            2. “读屏障”：并发回收时保证用户线程对对象的安全访问；                                                                                对延迟要求极高的关键业务（如高频交易、实时计算）
                                                                            仅在 “初始标记” 和 “最终标记” 阶段有极短的 STW（通常 < 1ms），其余阶段完全与用户线程并发	    
        Shenandoah	    标记 - 整理算法	            多线程（并发）	            与 ZGC 目标类似：低延迟、大内存，核心区别在于采用 “标记 - 整理算法”（无需复制对象，减少内存开销）
                                                                            核心技术：“连接指针”（用于并发整理时维护对象引用关系） 
                                                                            STW 时间同样控制在毫秒级以下，支持 TB 级堆内存
                                                                            特点：不依赖 HotSpot 虚拟机的特定功能（如 ZGC 的 “着色指针” 依赖 CPU 架构），兼容性更好	                                                 OpenJDK 专属（Oracle JDK 不包含） 、大内存、低延迟场景，且需要跨平台兼容的应用

6.常用JVM参数：
        -Xms：设置JVM初始堆大小。
        -Xmx：设置JVM最大堆大小。
        -Xmn：设置JVM新生代大小。
        -XX:PermSize：设置JVM方法区初始大小。
        -XX:MaxPermSize：设置JVM方法区最大大小。
        -XX:+UseSerialGC：启用Serial垃圾回收器。
        -XX:+UseParallelGC：启用Parallel垃圾回收器。
        -XX:+UseConcMarkSweepGC：启用CMS垃圾回收器。
        -XX:+UseG1GC：启用G1垃圾回收器。
        -XX:+UseZGC：启用ZGC垃圾回收器。
        -XX:+UseShenandoahGC：启用Shenandoah垃圾回收器。
        -XX:SurvivorRatio：设置新生代中Eden区与Survivor区的比例。
        -XX:MaxTenuringThreshold：设置对象在新生代中存活的最大年龄。
        -XX:+PrintGCDetails：打印详细的垃圾回收日志信息。
        -XX:+PrintGCTimeStamps：打印垃圾回收的时间戳信息。
        -XX:+HeapDumpOnOutOfMemoryError：在内存溢出时生成堆转储文。
        -XX:HeapDumpPath：指定堆转储文件的路径。
        -XX:+UseCompressedOops：启用压缩对象指针，减少内存占用，提高性能（适用于堆内存小于32GB的环境）。   

7.介绍下新生代、老年代、永久代
        新生代：用来存放新生的对象，一般占用堆的1/3空间。分为Eden区和两个Survivor区（S0、S1）。
        老年代：用来存放新生代中长期存在的对象。使用标记-清除算法或标记整理算法。
        永久代：用来存放"元数据"，即描述类本身的数据。永久代极少发生垃圾回收，回收时会回收不再被类引用的数据。
            永久代被元空间代替的原因：
                1.永久代大小固定，容易导致内存溢出。
                2.永久代属于堆内存的一部分，容易与对象争夺内存。
                3.永久代的垃圾回收效率低，影响性能。
8.介绍下minorGC和fullGC
        Minor GC（次要 GC）:主要针对新生代进行垃圾回收。当Eden区满时，会触发Minor GC，
            将存活对象复制到Survivor区，未被引用的对象则被回收。Minor GC通常较快，停顿时间较短。会触发Stop the world,但时间短;
        Full GC：针对整个堆（新生代和老年代）进行垃圾回收，有时也包括方法区。会触发Stop the world,时间长;
9.四种引用：强、软、若、虚
        强引用：只要引用存在，垃圾回收器就不会回收对象。
        软引用：垃圾回收器内存不足时会回收对象。
        弱引用：垃圾回收器下一次回收就会回收该对象。
        虚引用：无法通过引用访问对象，主要用于对象的回收通知。
10.JVM类加载机制：
        1.加载：JVM 将字节码文件（.class） 加载到内存中。
        2.验证：确保字节码文件符合JVM规范，不会危害虚拟机安全。
        3.准备：为静态变量分配内存并赋默认值。
        4.解析：将符号引用转为直接引用，包括类、方法、字段等的引用。
        5.初始化：执行静态代码块和静态变量赋值。
        6.使用：类的实际调用。
        7.卸载：垃圾回收器回收不再使用的类。
11.类的加载与双亲委派机制：
        1.类加载器分类：
    类加载器	                作用范围	                            加载路径（示例）	                        父加载器
    启动类加载器（Bootstrap）	加载 JVM 核心类库                 	JAVA_HOME/lib 目录下的 jar（如 rt.jar）	无（自身是顶层）
    扩展类加载器（Extension）	加载 JVM 扩展类库 javax.*开头的类	    JAVA_HOME/lib/ext 目录下的 jar	        Bootstrap（间接）
    应用类加载器（Application）加载用户编写的类                     	项目的target/classes、lib目录下的 jar	    Extension
        2.双亲委派模型:
        当一个类加载器需要加载某个类时，先委托给其父加载器加载，只有父加载器无法加载时，才由自身加载。
        双亲委派模型的优势：
        安全性：防止核心类被篡改。(String,HashMap啥的)
        唯一性：确保同一个类在 JVM 中只被加载一次。
        3.破坏双亲委派模型：
        自定义类加载器，重写findClass方法。
        使用Thread.currentThread().setContextClassLoader()设置线程上下文类加载器。
12.如果对象的引用被置为null，垃圾回收器是否会立即释放对象占用的内存？
        不会。原因有下：
        1.该对象虽然被判为null，但仍有可能在后续被其他异性引用。
        2.垃圾回收机制不会立即生效，即使对象真正被判定为垃圾，也需要等到内存满了，GC真正触发。

13.静态变量在什么时候加载？编译期还是运行期？
        在运行期加载。
        静态变量 和 静态代码块是在所属类第一次被使用的时候加载。

14.JDK1.8相对于1.7做了哪些JVM优化        
        1.永久代被元空间取代
        2.字符串常量池移至内存
        3.垃圾回收器优化
            1.引入G1垃圾回收器，适合大内存应用，兼顾吞吐量和延迟。
            2.优化CMS垃圾回收器，减少停顿时间，提高并发效率。
        4.压缩指针默认启用，对 64 位 JVM，默认压缩对象指针（从 64 位降至 32 位），减少内存占用和 CPU 缓存压力（JDK 1.7 需手动开启，JDK 1.8 默认启用）。
15.JVM内存溢出和内存泄漏的区别
        1.内存溢出（OutOfMemoryError）：
            定义：该被回收的对象没有被回收，是一种"隐性消耗"。
            原因：堆内存不足、栈内存不足、方法区内存不足等。
            解决：增加堆内存大小、优化代码、检查死循环等。
        2.内存泄漏（Memory Leak）：
            定义：程序需要分配的内存超过了JVM内存上线，是一种"显性失败"；
            原因：静态集合类未清理、监听器未注销、线程未关闭等。
            解决：及时清理不再使用的对象、使用弱引用等。
        总结：
            内存溢出是由于内存不足导致程序崩溃，而内存泄漏是由于对象无法被回收导致内存逐渐耗尽。内存泄漏可能最终引发内存溢出。
16.如何检测和解决JVM内存泄漏问题
        1.检测内存泄漏：
            1.使用JVM自带工具：jmap、jstat、jconsole等。
            2.使用第三方工具：VisualVM、Eclipse MAT、YourKit等。
            3.分析堆转储文件（Heap Dump），查找无法回收的对象。
        2.解决内存泄漏：
            1.检查代码，确保不再使用的对象引用被置为null。
            2.使用弱引用（WeakReference）或软引用（SoftReference）来引用不常用的对象。
            3.及时注销监听器、关闭线程等，避免长时间持有对象引用。
            4.定期监控应用的内存使用情况，及时发现和处理内存泄漏问题。
        3.内存泄露的典型原因：
            1.长生命周期对象持有短生命周期对象的引用：
                例如，静态集合（static List）中添加了临时对象后未及时移除，导致临时对象被静态引用长期持有，无法回收。
            2.未关闭资源：
                如数据库连接、IO 流、网络连接等资源未关闭。
            3.缓存使用不当：缓存没有设置过期策略。
            4.匿名内部类 / Lambda 表达式的隐式引用： 
                非静态内部类会隐式持有外部类的引用，若内部类被长期存储（如放入静态集合），会导致外部类对象无法回收。
17.设置堆空间的最大值-Xmx应该考虑什么因素
        1.应用的内存需求
            峰值内存消耗：通过压测或监控，确定应用在高负载（如峰值请求、大数据处理）时的最大内存使用量，-Xmx需至少覆盖此值（建议预留 10%~20% 缓冲）。
                例如：电商系统在秒杀活动时内存峰值为 8GB，-Xmx可设置为 10GB。
            对象创建特性：
                若应用频繁创建大对象（如批量处理数据）或长期持有大量对象（如缓存），需更大的堆空间。
                若对象生命周期短（如 Web 请求的临时对象），堆空间可适当减小（依赖 GC 高效回收）。
            内存泄露风险：若应用存在潜在内存泄露，过大的-Xmx会延缓 OOM 的发生，掩盖问题（建议先修复泄露，再合理设置堆大小）。
        2.物理机 / 容器的可用内存
            不超过系统总内存：-Xmx的值必须小于服务器 / 容器的总内存（包括操作系统、其他进程占用的内存），否则会导致内存交换（Swap）（当 JVM 内存超过物理内存时，系统将部分内存写入磁盘）。
            容器化环境限制：在docker等容器中，容器内存超限会被宿主机杀死。
        3.GC回收效率：
            堆过大：
                优点：GC 触发频率低（内存充足，对象可长时间存活）。
                缺点：单次 GC（尤其是 Full GC）时间长（需扫描和回收的内存区域大），可能导致长停顿（STW），影响延迟敏感的应用（如 Web 服务、交易系统）。
            堆过小：
                优点：单次 GC 时间短。
                缺点：GC 触发频繁（尤其是 Minor GC），频繁的 STW 会累积成性能损耗，且可能因内存不足导致对象提前进入老年代，加剧 Full GC 压力。
18.如何分析GC日志(了解即可)
        1.启用GC日志：
            在JDK 8及以下版本：
                -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:/path/to/gc.log
            在JDK 9及以上版本：
                -Xlog:gc*:file=/path/to/gc.log:time,uptime,level,tags
        2.理解GC日志内容：
            GC类型：Minor GC（新生代回收）、Major GC（老年代回收）、Full GC（全堆回收）。
            GC时间：每次GC的开始时间、持续时间。
            堆内存变化：GC前后各代内存使用情况（Eden、Survivor、Old）。
            GC原因：触发GC的原因（如内存不足、显式调用System.gc()等）。
        3.分析关键指标：
            GC频率：频繁的Minor GC可能表明新生代过小，频繁的Full GC可能表明老年代压力大或存在内存泄漏。
            GC停顿时间：长时间的STW会影响应用响应，需关注单次GC和累计GC时间。
            内存使用趋势：通过堆内存使用图，观察内存是否持续增长（可能存在内存泄漏）或周期性波动（正常GC行为）。
        4.使用工具辅助分析：
            使用VisualVM、Eclipse MAT、GCeasy等工具，可视化GC日志，帮助识别问题。
        5.优化建议：
            根据分析结果，调整堆大小（-Xmx、-Xms）、新生代大小（-Xmn）、Survivor比例（-XX:SurvivorRatio）等参数。
            优化代码，减少对象创建和持有时间，避免内存泄漏。
            选择合适的垃圾回收器（如G1、ZGC）以满足应用的延迟和吞吐量需求。
19.JDK8默认的垃圾回收器是什么
        JDK 8 默认的垃圾回收器是 Parallel Scavenge（新生代） + Parallel Old（老年代）组合。
        该组合以吞吐量优先为目标，适合对延迟不敏感、需要高吞吐量的后台任务和批处理场景。

        
    

        
        

    
    

    
    

	